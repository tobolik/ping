<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèì Ping pong turnaje</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        html, body { height: 100%; margin: 0; padding: 0; }
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .screen { display: none; }
        .screen.active { display: block; }
        #app { height: 100%; }
        .modal-backdrop {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center; z-index: 50;
            animation: fadeIn 0.2s ease;
        }
        .modal-content {
            background: white; padding: 1.5rem; border-radius: 0.75rem;
            width: 95vw; max-width: 500px;
            animation: slideUp 0.3s ease-out;
            max-height: 90vh; overflow-y: auto;
        }
        .modal-content.modal-lg { max-width: 800px; }
        .btn {
            display: inline-block; padding: 0.75rem 1.5rem; border-radius: 0.5rem;
            font-weight: 600; text-align: center; cursor: pointer;
            transition: all 0.2s; white-space: nowrap;
        }
        .btn:disabled { background-color: #d1d5db; cursor: not-allowed; color: #6b7280; }
        .btn-primary { background-color: #22c55e; color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #16a34a; }
        .btn-secondary { background-color: #e5e7eb; color: #374151; }
        .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
        .player-score-box.active-pointer:active { transform: scale(0.99); }
        .autocomplete-suggestions {
            position: absolute; background: white; border: 1px solid #d1d5db; border-top: none;
            border-radius: 0 0 0.5rem 0.5rem; z-index: 100; max-height: 150px; overflow-y: auto;
            left: 0; right: 0;
        }
        .autocomplete-suggestion { padding: 0.5rem 1rem; cursor: pointer; }
        .autocomplete-suggestion.highlighted { background-color: #f3f4f6; }
        .settings-menu {
            position: absolute;
            right: 0;
            top: calc(100% + 0.5rem);
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 40;
            overflow: hidden;
        }
        .settings-menu button, .settings-menu label {
            display: block;
            width: 100%;
            padding: 0.75rem 1.5rem;
            text-align: left;
            white-space: nowrap;
        }
        .settings-menu button:hover, .settings-menu label:hover {
            background-color: #f3f4f6;
        }
        #sound-toggle:checked ~ .toggle-checkbox { background-color: #22c55e; }
        #sound-toggle:checked ~ .toggle-checkbox .toggle-label { transform: translateX(100%); }
        #voice-assist-toggle:checked ~ .toggle-checkbox { background-color: #22c55e; }
        #voice-assist-toggle:checked ~ .toggle-checkbox .toggle-label { transform: translateX(100%); }
        #show-locked-toggle:checked ~ .toggle-checkbox { background-color: #22c55e; }
        #show-locked-toggle:checked ~ .toggle-checkbox .toggle-label { transform: translateX(100%); }
        
        @media (max-width: 768px) {
            html:has(body.game-active) {
                margin: 0 !important;
                padding: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                overflow: hidden !important;
            }
            body.game-active { 
                padding: 0 !important; 
                margin: 0 !important; 
                overflow: hidden !important;
                width: 100vw !important;
                height: 100vh !important;
            }
            body.game-active #app { 
                padding: 0 !important; 
                margin: 0 !important; 
                max-width: none !important;
                width: 100vw !important;
                height: 100vh !important;
                overflow: hidden !important;
            }
            body.game-active #game-screen { 
                height: 100vh !important; 
                width: 100vw !important;
                max-width: none !important;
                margin: 0 !important;
                padding: 0 !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
            }
            body.game-active #game-screen > div {
                width: 100% !important;
                height: 100vh !important;
                margin: 0 !important;
                padding: 0 !important;
                max-width: none !important;
            }
            body.game-active #game-screen .player-score-box {
                min-height: 0 !important;
            }
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body class="text-gray-800">

    <div id="app" class="max-w-xl mx-auto p-4">
        <div id="main-screen" class="screen space-y-6">
            <header class="flex justify-between items-center flex-wrap gap-4">
                <h1 class="text-3xl font-bold flex items-center gap-3"><i class="fa-solid fa-trophy text-yellow-400"></i>Ping pong turnaje</h1>
                <div class="flex items-center gap-2">
                    <button data-action="show-new-tournament-modal" class="btn btn-primary flex items-center gap-2"><i class="fa-solid fa-plus"></i> Nov√Ω turnaj</button>
                    <div class="relative">
                        <button data-action="toggle-settings-menu" class="btn btn-secondary !p-0 h-12 w-12 flex items-center justify-center text-xl" title="Nastaven√≠ aplikace"><i class="fa-solid fa-gear"></i></button>
                        <div id="settings-menu" class="settings-menu hidden">
                            <button data-action="show-player-db"><i class="fa-solid fa-database w-6 mr-2"></i>Spr√°va hr√°ƒç≈Ø</button>
                            <button data-action="show-overall-stats"><i class="fa-solid fa-chart-line w-6 mr-2"></i>Celkov√© statistiky</button>
                            <button data-action="export-data"><i class="fa-solid fa-file-export w-6 mr-2"></i>Exportovat data</button>
                            <label for="import-file" class="cursor-pointer inline-flex items-center"><i class="fa-solid fa-file-import w-6 mr-2"></i>Importovat data</label>
                            <input type="file" id="import-file" class="hidden" accept=".json">
                            <label for="sound-toggle" class="cursor-pointer flex items-center justify-between">
                                <span class="flex items-center"><i class="fa-solid fa-volume-high w-6 mr-2"></i>Zvuky</span>
                                <input type="checkbox" id="sound-toggle" data-action="toggle-sound" class="sr-only">
                                <div class="relative w-10 h-5 bg-gray-300 rounded-full transition-colors toggle-checkbox">
                                    <div class="absolute left-0 top-0 w-5 h-5 bg-white rounded-full shadow transform transition-transform toggle-label"></div>
                                </div>
                            </label>
                            <label for="voice-assist-toggle" class="cursor-pointer flex items-center justify-between">
                                <span class="flex items-center"><i class="fa-solid fa-microphone-lines w-6 mr-2"></i>Hlas</span>
                                <input type="checkbox" id="voice-assist-toggle" data-action="toggle-voice-assist" class="sr-only">
                                <div class="relative w-10 h-5 bg-gray-300 rounded-full transition-colors toggle-checkbox">
                                    <div class="absolute left-0 top-0 w-5 h-5 bg-white rounded-full shadow transform transition-transform toggle-label"></div>
                                </div>
                            </label>
                            <label for="show-locked-toggle" class="cursor-pointer flex items-center justify-between">
                                <span class="flex items-center"><i class="fa-solid fa-lock w-6 mr-2"></i>Zobrazit zamƒçen√© turnaje</span>
                                <input type="checkbox" id="show-locked-toggle" data-action="toggle-show-locked" class="sr-only">
                                <div class="relative w-10 h-5 bg-gray-300 rounded-full transition-colors toggle-checkbox">
                                    <div class="absolute left-0 top-0 w-5 h-5 bg-white rounded-full shadow transform transition-transform toggle-label"></div>
                                </div>
                            </label>
                        </div>
                    </div>
                </div>
            </header>
            <main id="tournaments-list-container" class="space-y-4"></main>
        </div>

        <div id="player-db-screen" class="screen space-y-6">
             <header><h1 class="text-3xl font-bold">Datab√°ze hr√°ƒç≈Ø</h1><p class="text-gray-500">Zde spravujete centr√°ln√≠ seznam v≈°ech hr√°ƒç≈Ø.</p></header>
            <div class="flex gap-2"><button data-action="show-edit-player-modal" data-id="new" class="btn btn-primary w-full"><i class="fa-solid fa-plus mr-2"></i>P≈ôidat nov√©ho hr√°ƒçe</button><button data-action="back-to-main" class="btn btn-secondary w-full">Zpƒõt</button></div>
            <main id="player-db-list-container" class="space-y-2"></main>
        </div>
        <div id="tournament-screen" class="screen space-y-6">
            <header><div id="tournament-title" class="text-3xl font-bold"></div><p id="tournament-progress" class="text-gray-500"></p></header>
            <div class="flex items-center gap-2"><button data-action="back-to-main" class="btn btn-secondary flex items-center justify-center gap-2"><i class="fa-solid fa-list-ul"></i> Turnaje</button><button data-action="show-stats" class="btn btn-secondary flex items-center justify-center gap-2"><i class="fa-solid fa-chart-simple"></i> Statistiky</button><button data-action="show-settings-modal" class="btn btn-secondary flex items-center justify-center gap-2 ml-auto"><i class="fa-solid fa-gear"></i> Nastaven√≠</button></div>
            <main class="space-y-6"><div id="final-results-container"></div><div id="upcoming-matches-container"></div><div id="completed-matches-container"></div></main>
        </div>
        <div id="game-screen" class="screen"></div>
        <div id="stats-screen" class="screen space-y-6">
            <header><h1 class="text-3xl font-bold">V√Ωsledkov√° listina</h1><p id="stats-tournament-name" class="text-gray-500"></p></header>
            <div class="flex gap-2">
                <button data-action="back-to-tournament" class="btn btn-secondary flex-1">Zpƒõt</button>
                <button data-action="export-csv" class="btn btn-primary flex-1"><i class="fa-solid fa-file-csv"></i> Export CSV</button>
                <button data-action="export-pdf" class="btn btn-primary flex-1"><i class="fa-solid fa-file-pdf"></i> Export PDF</button>
            </div>
            <div id="stats-leaderboard" class="bg-white p-4 rounded-xl shadow-sm"></div>
            <div id="stats-team-leaderboard" class="bg-white p-4 rounded-xl shadow-sm"></div>
            <div class="space-y-2"><h2 class="text-xl font-bold">Vz√°jemn√© z√°pasy</h2><div id="stats-matrix" class="bg-white p-4 rounded-xl shadow-sm overflow-x-auto"></div></div>
        </div>
        <div id="overall-stats-screen" class="screen space-y-6">
            <header><h1 class="text-3xl font-bold">Celkov√© statistiky hr√°ƒç≈Ø</h1></header>
            <button data-action="back-to-main" class="btn btn-secondary w-full">Zpƒõt</button>
            <div id="overall-stats-container" class="bg-white p-4 rounded-xl shadow-sm overflow-x-auto"></div>
        </div>
        <div id="modals-container"></div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    let state = { settings: { soundsEnabled: true, voiceAssistEnabled: false }, playerDatabase: [], tournaments: [], activeTournamentId: null, activeMatchId: null, scoreHistory: [] };
    const playerColors = ["bg-red-500", "bg-blue-500", "bg-green-500", "bg-purple-500", "bg-yellow-500", "bg-pink-500", "bg-indigo-500", "bg-teal-500"];
    const TOURNAMENT_TYPES = { SINGLE: 'single', DOUBLE: 'double' };
    const app = document.getElementById('app');
    const screens = { main: document.getElementById('main-screen'), playerDb: document.getElementById('player-db-screen'), tournament: document.getElementById('tournament-screen'), game: document.getElementById('game-screen'), stats: document.getElementById('stats-screen'), overallStats: document.getElementById('overall-stats-screen') };
    const modalsContainer = document.getElementById('modals-container');
    const STORAGE_KEY = 'pingPongTournamentData';
    const API_URL = 'api.php'; // P≈ôid√°me konstantu pro URL API
    let audioContext;
    let synth = window.speechSynthesis;
    let utterance = new SpeechSynthesisUtterance();

    const encouragingPhrases = [
        "Pojƒè, draku!", "To byl √∫der!", "Skvƒõl√° pr√°ce!", "Jen tak d√°l!", "To je ono!",
        "Par√°da!", "Kr√°sn√° hra.", "Nevad√≠, dal≈°√≠ m√≠ƒç je tv≈Øj.", "Zaber!", "Soust≈ôeƒè se.",
        "M√°≈° na to!", "V√Ωbornƒõ!", "Neskuteƒçn√©!", "Jak z partesu.", "Tohle se povedlo.",
        "Je≈°tƒõ jeden!", "To je bojovn√≠k.", "Kr√°sn√Ω bod.", "Ten m√° formu.", "To byla rychlost!",
        "N√°dhera.", "Neuvƒõ≈ôiteln√Ω reflex.", "To se cen√≠.", "Hraje jako b≈Øh.", "Z toho se nevyhrabe."
    ];

    const winningPhrases = [
        "To byla j√≠zda!", "Gratulujeme v√≠tƒõzi!", "N√°dhern√Ω v√Ωkon.", "Absolutnƒõ zaslou≈æen√© v√≠tƒõzstv√≠.",
        "A je to tam!", "Klobouk dol≈Ø.", "Tohle byl koncert.", "Bez ≈°ance.", "Fam√≥zn√≠!"
    ];

    const updateStateWithApiData = (data) => {
        state.settings = {
            soundsEnabled: true,
            voiceAssistEnabled: false,
            showLockedTournaments: false,
            ...(data.settings || {})
        };
        state.playerDatabase = (data.playerDatabase || []).map(p => ({
            id: parseInt(p.id, 10),
            name: p.name,
            photoUrl: p.photo_url,
            strengths: p.strengths,
            weaknesses: p.weaknesses
        }));
        state.tournaments = (data.tournaments || []).map(raw => {
            const normalizedMatches = (raw.matches || []).map(m => {
                let parsedRotation = null;
                if (m.double_rotation_state) {
                    try { parsedRotation = JSON.parse(m.double_rotation_state); } catch (e) { parsedRotation = null; }
                }
                return {
                    id: parseInt(m.id, 10),
                    player1Id: m.player1_id !== null ? parseInt(m.player1_id, 10) : null,
                    player2Id: m.player2_id !== null ? parseInt(m.player2_id, 10) : null,
                    team1Id: m.team1_id !== null ? parseInt(m.team1_id, 10) : null,
                    team2Id: m.team2_id !== null ? parseInt(m.team2_id, 10) : null,
                    score1: parseInt(m.score1, 10),
                    score2: parseInt(m.score2, 10),
                    completed: !!parseInt(m.completed, 10),
                    firstServer: m.first_server !== null ? parseInt(m.first_server, 10) : null,
                    servingPlayer: m.serving_player !== null ? parseInt(m.serving_player, 10) : null,
                    sidesSwapped: !!parseInt(m.sides_swapped, 10),
                    matchOrder: m.match_order !== null ? parseInt(m.match_order, 10) : 0,
                    doubleRotationState: parsedRotation
                };
            });
            return {
                id: parseInt(raw.id, 10),
                name: raw.name,
                pointsToWin: parseInt(raw.points_to_win ?? raw.pointsToWin ?? 11, 10),
                type: raw.type || TOURNAMENT_TYPES.SINGLE,
                isLocked: !!parseInt(raw.is_locked ?? raw.isLocked ?? 0, 10),
                createdAt: raw.createdAt,
                playerIds: (raw.playerIds || []).map(id => parseInt(id, 10)),
                teams: (raw.teams || []).map(team => ({
                    id: parseInt(team.id, 10),
                    playerIds: (team.playerIds || []).map(id => parseInt(id, 10)),
                    order: parseInt(team.order ?? team.team_order ?? 0, 10)
                })),
                matches: normalizedMatches
            };
        });
    };

    const apiCall = async (action, payload) => {
        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action, payload })
            });
            if (!response.ok) {
                const errorData = await response.json();
                console.error(`Chyba p≈ôi vol√°n√≠ akce '${action}':`, errorData.error);
                alert(`Chyba p≈ôi operaci: ${errorData.error}`);
            } else {
                const freshData = await response.json();
                if (freshData.tournaments) { // Aktualizujeme stav jen pokud p≈ôi≈°el cel√Ω datov√Ω objekt
                    updateStateWithApiData(freshData);
                }
            }
        } catch (error) {
            console.error(`Do≈°lo k chybƒõ s√≠tƒõ p≈ôi vol√°n√≠ akce '${action}':`, error);
            alert('Nepoda≈ôilo se prov√©st operaci. Zkontrolujte p≈ôipojen√≠.');
        }
    };

    const loadState = async () => {
        try {
            const response = await fetch(API_URL);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            updateStateWithApiData(data);
        } catch (error) {
            console.error('Error loading data from API:', error);
            alert('Nepoda≈ôilo se naƒç√≠st data ze serveru. Aplikace nemus√≠ fungovat spr√°vnƒõ.');
        }
    };
    
    function playSound(playerIndex) {
        if (!state.settings.soundsEnabled || !audioContext) return;
        if (audioContext.state === 'suspended') { audioContext.resume(); }
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
        const frequency = playerIndex === 1 ? 880 : 659.25;
        oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
        oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1);
    }
    
    function speak(text, force = false) {
        if ((!state.settings.voiceAssistEnabled && !force) || !synth) return;
        // Zru≈°√≠me p≈ôedchoz√≠ v√Ωstup, pokud nƒõjak√Ω je, aby se zpr√°vy nekumulovaly
        synth.cancel(); 
        let utterance = new SpeechSynthesisUtterance(text); // Vytvo≈ô√≠me novou instanci pro ka≈ædou hl√°≈°ku
        utterance.lang = 'cs-CZ';
        synth.speak(utterance);
    }
    
    // Funkce pro generov√°n√≠ unik√°tn√≠ho n√°zvu turnaje
    function generateUniqueTournamentName(baseName, excludeTournamentId = null) {
        // Odstran√≠me p≈ô√≠padn√© ƒç√≠slo na konci (nap≈ô. "Turnaj (2)" -> "Turnaj")
        let cleanBaseName = baseName;
        const nameMatch = cleanBaseName.match(/^(.+?)\s*\(\d+\)\s*$/);
        if (nameMatch) {
            cleanBaseName = nameMatch[1].trim();
        }
        
        // Zkontrolujeme, jestli z√°kladn√≠ n√°zev u≈æ existuje
        const existingNames = state.tournaments
            .filter(t => excludeTournamentId === null || t.id != excludeTournamentId)
            .map(t => t.name);
        
        if (!existingNames.includes(cleanBaseName)) {
            return cleanBaseName;
        }
        
        // Pokud existuje, p≈ôid√°me ƒç√≠slo v z√°vorce
        let copyNumber = 2;
        while (existingNames.includes(`${cleanBaseName} (${copyNumber})`)) {
            copyNumber++;
        }
        
        return `${cleanBaseName} (${copyNumber})`;
    }
    
    function initializeAudio() { if (!audioContext) { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } }

    const getGlobalPlayer = (id) => state.playerDatabase.find(p => p.id === id);
    const getTournament = (id = state.activeTournamentId) => state.tournaments.find(t => t.id === id);
    const getMatch = (tournament, matchId) => tournament.matches.find(m => m.id == matchId);
    const formatDate = (iso) => new Date(iso).toLocaleDateString('cs-CZ');
    const cloneState = (value) => value ? JSON.parse(JSON.stringify(value)) : null;
    const isDoubleTournament = (t) => (t?.type || TOURNAMENT_TYPES.SINGLE) === TOURNAMENT_TYPES.DOUBLE;
    const getPlayerColor = (tournament, playerId) => {
        const index = tournament.playerIds.indexOf(playerId);
        return playerColors[(index >= 0 ? index : 0) % playerColors.length];
    };
    const getTeamById = (t, teamId) => (t?.teams || []).find(team => team.id === teamId);
    const getTeamPlayerIds = (t, teamId) => {
        const team = getTeamById(t, teamId);
        return team ? [...team.playerIds] : [];
    };
    const getSidePlayerIds = (t, match, side) => {
        if (isDoubleTournament(t)) {
            const teamId = side === 1 ? match.team1Id : match.team2Id;
            const players = getTeamPlayerIds(t, teamId);
            if (players.length > 0) {
                return players;
            }
        }
        const playerId = side === 1 ? match.player1Id : match.player2Id;
        return playerId ? [playerId] : [];
    };
    const formatPlayersLabel = (playerIds) => {
        const names = playerIds
            .map(id => getGlobalPlayer(id)?.name)
            .filter(Boolean);
        return names.length ? names.join(' + ') : 'Nezn√°m√Ω t√Ωm';
    };
    const buildSideDescriptor = (t, playerIds, teamId) => {
        const primaryPlayerId = playerIds[0] ?? null;
        return {
            teamId,
            playerIds,
            label: formatPlayersLabel(playerIds),
            colorClass: primaryPlayerId !== null ? getPlayerColor(t, primaryPlayerId) : playerColors[0]
        };
    };
    const getDisplaySides = (t, match) => {
        const leftSideIndex = match.sidesSwapped ? 2 : 1;
        const rightSideIndex = match.sidesSwapped ? 1 : 2;
        const leftPlayers = getSidePlayerIds(t, match, leftSideIndex);
        const rightPlayers = getSidePlayerIds(t, match, rightSideIndex);
        const rawLeftPlayers = getSidePlayerIds(t, match, 1);
        const rawRightPlayers = getSidePlayerIds(t, match, 2);
        return {
            left: buildSideDescriptor(t, leftPlayers, leftSideIndex === 1 ? match.team1Id : match.team2Id),
            right: buildSideDescriptor(t, rightPlayers, rightSideIndex === 1 ? match.team1Id : match.team2Id),
            raw: {
                side1: buildSideDescriptor(t, rawLeftPlayers, match.team1Id),
                side2: buildSideDescriptor(t, rawRightPlayers, match.team2Id)
            }
        };
    };
    const getTournamentTypeLabel = (t) => isDoubleTournament(t) ? 'ƒåty≈ôhra' : 'Dvouhra';
    const getPlayerLimitForType = (type) => type === TOURNAMENT_TYPES.DOUBLE ? 16 : 8;
    const getMinPlayersForType = (type) => type === TOURNAMENT_TYPES.DOUBLE ? 4 : 2;
    const getTeamKey = (playerIds) => [...playerIds].sort((a, b) => a - b).join('-');
    const getMatchResultForPlayers = (t, match, playerAId, playerBId) => {
        const side1 = getSidePlayerIds(t, match, 1);
        const side2 = getSidePlayerIds(t, match, 2);
        const aOnSide1 = side1.includes(playerAId);
        const aOnSide2 = side2.includes(playerAId);
        const bOnSide1 = side1.includes(playerBId);
        const bOnSide2 = side2.includes(playerBId);
        if ((aOnSide1 && bOnSide2) || (aOnSide2 && bOnSide1)) {
            const aScore = aOnSide1 ? match.score1 : match.score2;
            const bScore = bOnSide1 ? match.score1 : match.score2;
            return { aScore, bScore };
        }
        return null;
    };
    const showScreen = (screenName) => { 
        const isGameScreen = screenName === 'game';
        if (!isGameScreen) {
            document.body.classList.remove('game-active');
            app.classList.add('max-w-xl', 'mx-auto', 'p-4');
        }
        Object.values(screens).forEach(s => s.classList.remove('active')); 
        if(screens[screenName]) screens[screenName].classList.add('active'); 
        window.scrollTo(0,0); 
    };
    const openModal = (html) => { modalsContainer.innerHTML = html; };
    const closeModal = () => { modalsContainer.innerHTML = ''; };
    const getCzechPlayerDeclension = (count) => { if (count === 1) return 'hr√°ƒç'; if (count >= 2 && count <= 4) return 'hr√°ƒçi'; return 'hr√°ƒç≈Ø'; };
    const renderGameScreen = (content) => { 
        document.body.classList.add('game-active');
        app.classList.remove('max-w-xl', 'mx-auto', 'p-4');
        screens.game.innerHTML = content; 
        showScreen('game'); 
    };
    
    const templates = {
        leaderboardTable: (stats, t) => `<div class="overflow-x-auto"><table class="w-full text-left"><thead><tr class="border-b"><th class="p-2">Poz.</th><th class="p-2">Hr√°ƒç</th><th class="p-2 text-center">V√≠tƒõzstv√≠</th><th class="p-2 text-center">Por√°≈æky</th><th class="p-2 text-center">Odehr√°no</th><th class="p-2 text-center">√öspƒõ≈°nost</th></tr></thead><tbody>${stats.map((s, i) => `<tr class="border-b last:border-none"><td class="p-2 font-bold">${i === 0 && s.wins > 0 ? 'üèÜ' : `#${i+1}`}</td><td class="p-2 flex items-center gap-2"><div class="w-4 h-4 rounded-full ${playerColors[t.playerIds.indexOf(s.player.id) % playerColors.length]}"></div> ${s.player.name}</td><td class="p-2 text-center font-bold text-green-600">${s.wins}</td><td class="p-2 text-center text-red-500">${s.losses}</td><td class="p-2 text-center">${s.played}</td><td class="p-2 text-center font-semibold">${s.played > 0 ? Math.round((s.wins / s.played) * 100) : 0}%</td></tr>`).join('')}</tbody></table></div>`,
        teamLeaderboard: (stats) => stats.length ? `<div class="mt-4"><h3 class="text-lg font-semibold mb-2">T√Ωmy</h3><div class="overflow-x-auto"><table class="w-full text-left text-sm"><thead><tr class="border-b"><th class="p-2">Poz.</th><th class="p-2">T√Ωm</th><th class="p-2 text-center">V</th><th class="p-2 text-center">P</th><th class="p-2 text-center">Odehr√°no</th><th class="p-2 text-center">Sk√≥re</th></tr></thead><tbody>${stats.map((s, i) => `<tr class="border-b last:border-none"><td class="p-2 font-bold">${i === 0 && s.wins > 0 ? 'ü•á' : `#${i+1}`}</td><td class="p-2">${s.label}</td><td class="p-2 text-center text-green-600 font-semibold">${s.wins}</td><td class="p-2 text-center text-red-500">${s.losses}</td><td class="p-2 text-center">${s.played}</td><td class="p-2 text-center">${s.scoreFor}:${s.scoreAgainst}</td></tr>`).join('')}</tbody></table></div></div>` : ''
    };

    function generateMatchesForTournament(tournament) {
        if (isDoubleTournament(tournament)) return;
        const playerIds = tournament.playerIds;
        for (let i = 0; i < playerIds.length; i++) {
            for (let j = i + 1; j < playerIds.length; j++) {
                const p1Id = playerIds[i]; const p2Id = playerIds[j];
                const matchExists = tournament.matches.some(m => (m.player1Id === p1Id && m.player2Id === p2Id) || (m.player1Id === p2Id && m.player2Id === p1Id));
                if (!matchExists) {
                    tournament.matches.push({ id: `${p1Id}-${p2Id}-${Date.now()}`, player1Id: p1Id, player2Id: p2Id, score1: 0, score2: 0, completed: false, firstServer: null, servingPlayer: null });
                }
            }
        }
    }

    function smartShuffleMatches(matches) {
        if (!matches.length) return [];
        if (matches.length < 3) return matches.sort(() => Math.random() - 0.5);
        let remaining = [...matches];
        let shuffled = [];
        let lastPlayers = [];
        if (remaining.length > 0) {
            const firstMatchIndex = Math.floor(Math.random() * remaining.length);
            const firstMatch = remaining.splice(firstMatchIndex, 1)[0];
            shuffled.push(firstMatch);
            lastPlayers = [firstMatch.player1Id, firstMatch.player2Id];
        }
        while(remaining.length > 0) {
            let possibleNext = remaining.filter(match => !lastPlayers.includes(match.player1Id) && !lastPlayers.includes(match.player2Id));
            if (possibleNext.length === 0) {
                possibleNext = remaining;
            }
            const nextMatchIndex = Math.floor(Math.random() * possibleNext.length);
            const nextMatch = possibleNext[nextMatchIndex];
            shuffled.push(nextMatch);
            lastPlayers = [nextMatch.player1Id, nextMatch.player2Id];
            remaining = remaining.filter(m => m.id !== nextMatch.id);
        }
        return shuffled;
    }
    
    const renderPlayerDbScreen = () => {
        const container = document.getElementById('player-db-list-container');
        if(state.playerDatabase.length === 0) { container.innerHTML = `<div class="text-center text-gray-500 p-8 bg-white rounded-xl">Datab√°ze je pr√°zdn√°. P≈ôidejte prvn√≠ho hr√°ƒçe.</div>`; } 
        else {
            container.innerHTML = state.playerDatabase.sort((a,b) => a.name.localeCompare(b.name)).map(p => {
                const photo = p.photoUrl || `data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2240%22%20height%3D%2240%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Crect%20width%3D%2240%22%20height%3D%2240%22%20fill%3D%22%23e5e7eb%22%20rx%3D%2220%22%2F%3E%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20dominant-baseline%3D%22central%22%20text-anchor%3D%22middle%22%20font-family%3D%22Inter%22%20font-size%3D%2216%22%20fill%3D%22%239ca3af%22%3E${p.name.charAt(0).toUpperCase()}%3C%2Ftext%3E%3C%2Fsvg%3E`;
                return `<div class="bg-white p-3 rounded-xl shadow-sm flex items-center justify-between"><div class="flex items-center gap-3"><img src="${photo}" class="w-10 h-10 rounded-full object-cover bg-gray-200"><span class="font-semibold">${p.name}</span></div><div><button data-action="show-edit-player-modal" data-id="${p.id}" class="btn btn-secondary !p-2 h-10 w-10" title="Upravit hr√°ƒçe"><i class="fa-solid fa-pencil"></i></button><button data-action="delete-player" data-id="${p.id}" class="btn btn-danger !p-2 h-10 w-10" title="Smazat hr√°ƒçe"><i class="fa-solid fa-trash"></i></button></div></div>`;
            }).join('');
        }
        showScreen('playerDb');
    };
    
    const getTournamentStatus = (t) => {
        const completedCount = t.matches.filter(m => m.completed).length;
        const totalMatches = t.matches.length;
        if (totalMatches > 0 && completedCount === totalMatches) {
            return { icon: 'fa-trophy', color: 'text-yellow-500', text: 'Dokonƒçeno' };
        }
        if (completedCount > 0 || t.matches.some(m => m.score1 > 0 || m.score2 > 0)) {
            return { icon: 'fa-person-running', color: 'text-blue-500', text: 'Prob√≠h√°' };
        }
        return { icon: 'fa-play-circle', color: 'text-gray-400', text: 'P≈ôipraveno' };
    };

    const renderMainScreen = () => {
        const container = document.getElementById('tournaments-list-container');
        // Filtrujeme turnaje podle nastaven√≠ zobrazen√≠ zamƒçen√Ωch turnaj≈Ø
        const showLocked = state.settings.showLockedTournaments || false;
        const visibleTournaments = showLocked ? state.tournaments : state.tournaments.filter(t => !t.isLocked);
        
        if (visibleTournaments.length === 0) {
            container.innerHTML = `<div class="text-center py-10 px-6 bg-white rounded-xl shadow-sm"><i class="fa-solid fa-trophy text-5xl text-gray-300"></i><h2 class="text-xl font-semibold text-gray-700 mt-4">≈Ω√°dn√© turnaje</h2><p class="text-gray-500 mt-1">Vytvo≈ôte sv≈Øj prvn√≠ ping pongov√Ω turnaj</p><button data-action="show-new-tournament-modal" class="btn btn-primary mt-4">Vytvo≈ôit turnaj</button></div>`;
        } else {
            container.innerHTML = visibleTournaments.sort((a,b) => b.id - a.id).map(t => {
                const completedCount = t.matches.filter(m => m.completed).length; const totalMatches = t.matches.length;
                const isFinished = totalMatches > 0 && completedCount === totalMatches;
                let winnerInfo = '';
                if (isFinished) { const stats = calculateStats(t); const winnerId = stats.length > 0 && stats[0].wins > 0 ? stats[0].player.id : null; const winner = winnerId ? getGlobalPlayer(winnerId) : null; winnerInfo = `<p class="font-bold text-yellow-500"><i class="fa-solid fa-trophy"></i> V√≠tƒõz: ${winner ? winner.name : 'Rem√≠za'}</p>`; }
                const status = getTournamentStatus(t);
                const nameClass = t.isLocked ? 'text-gray-500' : '';
                
                let buttonText = "Zobrazit";
                let buttonClass = "btn-secondary";

                if (status.text === 'P≈ôipraveno') {
                    buttonText = "Start turnaje";
                    buttonClass = "btn-primary";
                } else if (status.text === 'Prob√≠h√°') {
                    buttonText = "Pokraƒçovat v turnaji";
                    buttonClass = "bg-blue-500 hover:bg-blue-600 text-white";
                } else if (status.text === 'Dokonƒçeno') {
                    buttonText = "Zobrazit v√Ωsledky";
                    buttonClass = "bg-yellow-400 hover:bg-yellow-500 text-black";
                }

                return `<div class="bg-white p-4 rounded-xl shadow-sm space-y-3"><div class="flex justify-between items-start"><div><h2 class="text-xl font-bold ${nameClass}">${t.name}</h2><p class="text-sm text-gray-500">${t.playerIds.length} ${getCzechPlayerDeclension(t.playerIds.length)} &bull; ${getTournamentTypeLabel(t)} &bull; ${completedCount}/${totalMatches} z√°pas≈Ø &bull; Vytvo≈ôeno: ${formatDate(t.createdAt)}</p>${winnerInfo}</div><div class="flex items-center gap-3 text-xl text-gray-400"><i class="fa-solid ${status.icon} ${status.color}" title="${status.text}"></i><button data-action="toggle-lock-main" data-id="${t.id}" class="text-xl" title="${t.isLocked ? 'Odemknout turnaj' : 'Zamknout turnaj'}">${t.isLocked ? 'üîí' : 'üîì'}</button></div></div>${!t.isLocked ? `<button data-action="open-tournament" data-id="${t.id}" class="btn ${buttonClass} w-full">${buttonText}</button>`: ''}</div>`;
            }).join('');
        }
        showScreen('main');
    };

    const renderTournamentScreen = () => {
        const t = getTournament(); if (!t) { renderMainScreen(); return; }
        document.getElementById('tournament-title').innerHTML = `<div class="flex items-center gap-2"><span id="tournament-name-text">${t.name}</span><button data-action="quick-edit-name" class="btn btn-secondary !p-0 w-8 h-8 text-xs flex-shrink-0" title="Rychl√° √∫prava n√°zvu"><i class="fa-solid fa-pencil"></i></button></div>`;
        document.getElementById('tournament-progress').textContent = `${t.matches.filter(m => m.completed).length}/${t.matches.length} z√°pas≈Ø dokonƒçeno`;
        
        const renderMatch = (m, isCompleted, index) => {
            const sides = getDisplaySides(t, m);
            if (!sides.left.playerIds.length || !sides.right.playerIds.length) return '';
            const isSuspended = !isCompleted && m.firstServer !== null;
            const servingIndicator = ' <span class="text-base">üèì</span>';
            const servingPlayerId = m.servingPlayer;
            const serveBadge = (side) => (isSuspended && servingPlayerId && side.playerIds.includes(servingPlayerId)) ? servingIndicator : '';
            const makeBadge = (side, alignRight = false, highlight = false) => `
                <div class="flex ${alignRight ? 'justify-end text-right' : 'justify-start'} items-center gap-2 w-2/5 ${highlight ? 'font-extrabold' : ''}">
                    ${alignRight ? '' : `<div class="w-6 h-6 ${side.colorClass} rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">${side.label.charAt(0).toUpperCase()}</div>`}
                    <div class="flex flex-col ${alignRight ? 'items-end' : 'items-start'}">
                        <span>${side.label}${serveBadge(side)}</span>
                        ${isDoubleTournament(t) ? `<span class="text-xs text-gray-500">${side.playerIds.map(id => getGlobalPlayer(id)?.name || '???').join(' ‚Ä¢ ')}</span>` : ''}
                    </div>
                    ${alignRight ? `<div class="w-6 h-6 ${side.colorClass} rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">${side.label.charAt(0).toUpperCase()}</div>` : ''}
                </div>
            `;
            const upcomingMatches = t.matches.filter(x => !x.completed);
            if (isCompleted) {
                const winnerSide = m.score1 === m.score2 ? null : (m.score1 > m.score2 ? 1 : 2);
                const scoreDisplay = m.sidesSwapped ? `${m.score2} : ${m.score1}` : `${m.score1} : ${m.score2}`;
                const leftHighlight = (m.sidesSwapped ? winnerSide === 2 : winnerSide === 1);
                const rightHighlight = (m.sidesSwapped ? winnerSide === 1 : winnerSide === 2);
                return `<div class="bg-white p-3 rounded-xl shadow-sm flex items-center justify-between mt-2 gap-2">
                    <div class="flex items-center gap-2 flex-grow">
                        ${makeBadge(sides.left, false, leftHighlight)}
                        <div class="font-bold text-lg">${scoreDisplay}</div>
                        ${makeBadge(sides.right, true, rightHighlight)}
                    </div>
                    <button data-action="edit-match" data-id="${m.id}" class="btn bg-yellow-400 hover:bg-yellow-500 text-white aspect-square !p-0 w-10 h-10" title="Upravit v√Ωsledek" ${t.isLocked ? 'disabled' : ''}>
                        <i class="fa-solid fa-pencil"></i>
                    </button>
                </div>`;
            }

            const scoreOrVs = isSuspended
                ? `<div class="font-bold text-lg">${m.sidesSwapped ? m.score2 : m.score1} : ${m.sidesSwapped ? m.score1 : m.score2}</div>`
                : `<div class="text-gray-400">vs</div>`;

            return `<div class="bg-white p-3 rounded-xl shadow-sm flex items-center justify-between mt-2 gap-2">
                <div class="flex items-center gap-1">
                    <button data-action="move-match" data-id="${m.id}" data-dir="up" class="btn btn-secondary !p-0 w-6 h-6 text-xs" ${index === 0 ? 'disabled' : ''} title="Posunout nahoru">‚ñ≤</button>
                    <button data-action="move-match" data-id="${m.id}" data-dir="down" class="btn btn-secondary !p-0 w-6 h-6 text-xs" ${index === upcomingMatches.length - 1 ? 'disabled' : ''} title="Posunout dol≈Ø">‚ñº</button>
                </div>
                <button data-action="swap-sides" data-id="${m.id}" class="btn btn-secondary !p-0 w-8 h-8 flex-shrink-0" title="Prohodit strany"><i class="fa-solid fa-right-left"></i></button>
                <div class="flex items-center gap-2 flex-grow">
                    ${makeBadge(sides.left, false, false)}
                    ${scoreOrVs}
                    ${makeBadge(sides.right, true, false)}
                </div>
                <button data-action="play-match" data-id="${m.id}" class="btn btn-primary aspect-square !p-0 w-10 h-10 text-lg" title="${isSuspended ? 'Pokraƒçovat v z√°pase' : 'Hr√°t z√°pas'}" ${t.isLocked ? 'disabled' : ''}>
                    ${isSuspended ? '<i class="fa-solid fa-clock-rotate-left"></i>' : '<i class="fa-solid fa-play"></i>'}
                </button>
            </div>`;
        };

        const upcomingContainer = document.getElementById('upcoming-matches-container');
        const completedContainer = document.getElementById('completed-matches-container');
        const finalResultsContainer = document.getElementById('final-results-container');
        
        const completedCount = t.matches.filter(m => m.completed).length;
        const totalMatches = t.matches.length;
        const isFinished = totalMatches > 0 && completedCount === totalMatches;

        upcomingContainer.innerHTML = ''; completedContainer.innerHTML = ''; finalResultsContainer.innerHTML = '';

        if(isFinished) {
            const stats = calculateStats(t);
            const winner = stats.length > 0 && stats[0].wins > 0 ? stats[0].player : null;
            const trophyIcons = ['', 'ü•à', 'ü•â'];
            finalResultsContainer.innerHTML = `<div class="bg-white p-6 rounded-xl shadow-sm text-center"><h2 class="text-2xl font-bold mb-2">Turnaj skonƒçil!</h2>${winner ? `<p class="text-gray-600">Celkov√Ωm v√≠tƒõzem je</p><p class="text-3xl font-bold my-2">üèÜ ${winner.name}</p>` : ''}<ol class="space-y-3 mt-4 text-left inline-block">${stats.slice(1).map((s, i) => `<li class="flex items-center text-lg"><span class="font-bold w-10 text-center">${i + 1 < 3 ? trophyIcons[i+1] : `#${i+2}`}</span><span>${s.player.name}</span></li>`).join('')}</ol></div>`;
        } else {
            const upcoming = t.matches.filter(m => !m.completed);
            upcomingContainer.innerHTML = upcoming.length > 0 ? `<h2 class="text-xl font-bold">Nadch√°zej√≠c√≠ z√°pasy</h2>${upcoming.map((m,i) => renderMatch(m, false, i)).join('')}` : (t.matches.length > 0 ? '' : `<div class="text-center p-4 bg-white rounded-xl text-gray-500">≈Ω√°dn√© z√°pasy. P≈ôidejte hr√°ƒçe v nastaven√≠.</div>`);
        }
        
        const completed = t.matches.filter(m => m.completed);
        completedContainer.innerHTML = completed.length > 0 ? `<h2 class="text-xl font-bold">Dokonƒçen√© z√°pasy</h2>${completed.map(m => renderMatch(m, true, -1)).join('')}` : '';
        showScreen('tournament');
    };
    
    let tempPlayerIds = []; let tempTournamentType = TOURNAMENT_TYPES.SINGLE; let autocompleteIndex = -1;

    function setupAutocomplete(inputId, containerId, onSelect, currentIds) {
        const input = document.getElementById(inputId); const suggestionsContainer = document.getElementById(containerId);
        const updateHighlight = () => {
            const items = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
            items.forEach((item, index) => item.classList.toggle('highlighted', index === autocompleteIndex));
        };
        const showSuggestions = () => {
            const value = input.value.toLowerCase(); suggestionsContainer.innerHTML = ''; autocompleteIndex = -1;
            if (true) {
                const filteredPlayers = state.playerDatabase.filter(p => p.name.toLowerCase().includes(value) && !currentIds.includes(p.id));
                if (filteredPlayers.length > 0) {
                    const suggestionsEl = document.createElement('div'); suggestionsEl.className = 'autocomplete-suggestions';
                    filteredPlayers.forEach((p, index) => {
                        const suggestionEl = document.createElement('div'); suggestionEl.className = 'autocomplete-suggestion'; suggestionEl.textContent = p.name;
                        suggestionEl.addEventListener('click', () => { onSelect(p.id); input.value = ''; suggestionsContainer.innerHTML = ''; input.focus(); });
                        suggestionEl.addEventListener('mouseover', () => { autocompleteIndex = index; updateHighlight(); });
                        suggestionsEl.appendChild(suggestionEl);
                    });
                    suggestionsContainer.appendChild(suggestionsEl);
                }
            }
        };
        input.addEventListener('input', showSuggestions); input.addEventListener('focus', showSuggestions);
        input.addEventListener('keydown', (e) => {
            const items = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
            if (e.key === 'ArrowDown') { e.preventDefault(); if (autocompleteIndex < items.length - 1) autocompleteIndex++; updateHighlight(); } 
            else if (e.key === 'ArrowUp') { e.preventDefault(); if (autocompleteIndex > 0) autocompleteIndex--; updateHighlight(); } 
            else if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteIndex > -1 && items[autocompleteIndex]) { items[autocompleteIndex].click(); } 
                else if (input.value.trim() !== '') {
                    const name = input.value.trim(); const existingPlayer = state.playerDatabase.find(p => p.name.toLowerCase() === name.toLowerCase());
                    if (existingPlayer) { if (!currentIds.includes(existingPlayer.id)) onSelect(existingPlayer.id); } 
                    else { if (confirm(`Hr√°ƒç "${name}" neexistuje. Chcete ho p≈ôidat do datab√°ze a turnaje?`)) { const newPlayer = { id: Date.now(), name, photoUrl: '', strengths: '', weaknesses: '' }; state.playerDatabase.push(newPlayer); saveState(); onSelect(newPlayer.id); } }
                    input.value = ''; suggestionsContainer.innerHTML = '';
                }
            }
        });
        document.addEventListener('click', (e) => { if (suggestionsContainer && !suggestionsContainer.parentElement.contains(e.target)) suggestionsContainer.innerHTML = ''; });
    }
    
    const calculateStats = (t) => {
        const statsMap = new Map();
        t.playerIds.forEach(id => {
            statsMap.set(id, { player: getGlobalPlayer(id), played: 0, wins: 0, losses: 0, scoreFor: 0, scoreAgainst: 0 });
        });
        t.matches.filter(m => m.completed).forEach(m => {
            const side1Players = getSidePlayerIds(t, m, 1);
            const side2Players = getSidePlayerIds(t, m, 2);
            const winnerSide = m.score1 === m.score2 ? null : (m.score1 > m.score2 ? 1 : 2);
            side1Players.forEach(id => {
                const stat = statsMap.get(id);
                if (!stat) return;
                stat.played++;
                stat.scoreFor += m.score1;
                stat.scoreAgainst += m.score2;
                if (winnerSide === 1) stat.wins++; else if (winnerSide === 2) stat.losses++;
            });
            side2Players.forEach(id => {
                const stat = statsMap.get(id);
                if (!stat) return;
                stat.played++;
                stat.scoreFor += m.score2;
                stat.scoreAgainst += m.score1;
                if (winnerSide === 2) stat.wins++; else if (winnerSide === 1) stat.losses++;
            });
        });
        return Array.from(statsMap.values())
            .filter(s => s.player)
            .sort((a, b) => {
                if (b.wins !== a.wins) return b.wins - a.wins;
                const scoreDiffA = a.scoreFor - a.scoreAgainst; const scoreDiffB = b.scoreFor - b.scoreAgainst;
                if (scoreDiffB !== scoreDiffA) return scoreDiffB - scoreDiffA;
                return b.scoreFor - a.scoreFor;
            });
    };
    const calculateTeamStats = (t) => {
        if (!isDoubleTournament(t)) return [];
        const statsMap = new Map();
        (t.teams || []).forEach(team => {
            statsMap.set(team.id, {
                team,
                label: formatPlayersLabel(team.playerIds),
                played: 0,
                wins: 0,
                losses: 0,
                scoreFor: 0,
                scoreAgainst: 0
            });
        });
        t.matches.filter(m => m.completed).forEach(m => {
            const team1 = statsMap.get(m.team1Id);
            const team2 = statsMap.get(m.team2Id);
            if (!team1 || !team2) return;
            team1.played++; team2.played++;
            team1.scoreFor += m.score1; team1.scoreAgainst += m.score2;
            team2.scoreFor += m.score2; team2.scoreAgainst += m.score1;
            if (m.score1 > m.score2) { team1.wins++; team2.losses++; } else { team2.wins++; team1.losses++; }
        });
        return Array.from(statsMap.values()).sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            const diffA = a.scoreFor - a.scoreAgainst;
            const diffB = b.scoreFor - b.scoreAgainst;
            if (diffB !== diffA) return diffB - diffA;
            return b.scoreFor - a.scoreFor;
        });
    };
    
    const checkWinCondition = (match, pointsToWin) => {
        if (match.score1 >= pointsToWin && match.score1 >= match.score2 + 2) return 1;
        if (match.score2 >= pointsToWin && match.score2 >= match.score1 + 2) return 2;
        return null;
    };
    
    const getDoubleServeBlockSize = (match, tournament) => {
        const base = tournament.pointsToWin === 21 ? 5 : 2;
        const deuceThreshold = tournament.pointsToWin - 1;
        if (match.score1 >= deuceThreshold && match.score2 >= deuceThreshold) {
            return 1;
        }
        return base;
    };

    const initializeDoubleRotationState = (tournament, match, firstServerSide) => {
        const team1Players = getSidePlayerIds(tournament, match, 1);
        const team2Players = getSidePlayerIds(tournament, match, 2);
        const order = [
            { playerId: team1Players[0], side: 1 },
            { playerId: team2Players[0], side: 2 },
            { playerId: team1Players[1], side: 1 },
            { playerId: team2Players[1], side: 2 }
        ].filter(entry => entry.playerId);
        if (!order.length) {
            match.doubleRotationState = null;
            match.servingPlayer = null;
            return;
        }
        const startingIndex = firstServerSide === 1 ? 0 : 1;
        match.doubleRotationState = {
            order,
            currentIndex: startingIndex % order.length,
            pointsServedThisTurn: 0
        };
        match.servingPlayer = order[startingIndex % order.length]?.playerId ?? null;
    };

    const advanceDoubleServeState = (match, tournament) => {
        if (!match.doubleRotationState || !match.doubleRotationState.order?.length) return;
        const blockSize = getDoubleServeBlockSize(match, tournament);
        match.doubleRotationState.pointsServedThisTurn = (match.doubleRotationState.pointsServedThisTurn || 0) + 1;
        if (match.doubleRotationState.pointsServedThisTurn >= blockSize) {
            match.doubleRotationState.pointsServedThisTurn = 0;
            match.doubleRotationState.currentIndex = (match.doubleRotationState.currentIndex + 1) % match.doubleRotationState.order.length;
        }
        match.servingPlayer = match.doubleRotationState.order[match.doubleRotationState.currentIndex]?.playerId ?? null;
    };

    const recalculateServiceState = (match, tournament) => {
        if (isDoubleTournament(tournament)) {
            if (match.doubleRotationState && match.doubleRotationState.order?.length) {
                const idx = match.doubleRotationState.currentIndex ?? 0;
                match.servingPlayer = match.doubleRotationState.order[idx % match.doubleRotationState.order.length]?.playerId ?? null;
            }
            return;
        }
        const pointsToWin = tournament.pointsToWin;
        const totalScore = match.score1 + match.score2;
        const p1Id = match.player1Id;
        const p2Id = match.player2Id;

        if (!match.firstServer) {
            match.servingPlayer = null;
            return;
        }
        
        const firstServerId = match.firstServer === 1 ? p1Id : p2Id;
        const otherPlayerId = match.firstServer === 1 ? p2Id : p1Id;

        const deuceThreshold = pointsToWin - 1;
        if (match.score1 >= deuceThreshold && match.score2 >= deuceThreshold) {
            const pointsIntoDeuce = (match.score1 - deuceThreshold) + (match.score2 - deuceThreshold);
            const serverAtDeuceStart = (Math.floor((deuceThreshold * 2) / 2) % 2 === 0) ? firstServerId : otherPlayerId;
            match.servingPlayer = (pointsIntoDeuce % 2 === 0) ? serverAtDeuceStart : (serverAtDeuceStart === firstServerId ? otherPlayerId : firstServerId);
            return;
        }

        if (totalScore === 0) {
            match.servingPlayer = firstServerId;
            return;
        }
        
        const pointsAfterFirst = totalScore - 1;
        const serviceBlockIndex = Math.floor(pointsAfterFirst / 2);

        if (serviceBlockIndex % 2 === 0) { // Blocks 0, 2, 4...
            match.servingPlayer = otherPlayerId;
        } else { // Blocks 1, 3, 5...
            match.servingPlayer = firstServerId;
        }
    };

    const undoLastPoint = async () => {
        const t = getTournament();
        const m = getMatch(t, state.activeMatchId);
        if (!t || !m || state.scoreHistory.length === 0) return;
        
        // Z√≠sk√°me posledn√≠ stav z historie
        const lastState = state.scoreHistory.pop();
        
        // Ovƒõ≈ô√≠me, ≈æe historie pat≈ô√≠ k aktu√°ln√≠mu z√°pasu
        if (lastState.matchId !== m.id) {
            state.scoreHistory.push(lastState); // Vr√°t√≠me zpƒõt, pokud to nen√≠ spr√°vn√Ω z√°pas
            return;
        }
        
        // Obnov√≠me stav
        m.score1 = lastState.score1;
        m.score2 = lastState.score2;
        m.servingPlayer = lastState.servingPlayer;
        m.firstServer = lastState.firstServer;
        m.doubleRotationState = cloneState(lastState.doubleRotationState);
        
        // Znovu vypoƒç√≠t√°me stav pod√°n√≠
        if (m.firstServer) {
            recalculateServiceState(m, t);
        }
        
        // Aktualizujeme v datab√°zi
        const matchPayload = { ...m, tournament_id: t.id, match_order: t.matches.findIndex(match => match.id == m.id) };
        await apiCall('updateMatch', { id: m.id, data: matchPayload });
        
        // Znovu vykresl√≠me obrazovku
        renderGameBoard();
    };

    const updateScore = async (playerId, delta, sideOverride = null) => {
        const t = getTournament(); 
        const m = getMatch(t, state.activeMatchId);
        if (!t || !m) return;

        const sidePlayers = {
            1: getSidePlayerIds(t, m, 1),
            2: getSidePlayerIds(t, m, 2)
        };
        const scoringSide = sideOverride ?? (playerId !== null
            ? (sidePlayers[1].includes(playerId) ? 1 : (sidePlayers[2].includes(playerId) ? 2 : null))
            : null);
        if (scoringSide === null) return;
        const scoreProp = scoringSide === 1 ? 'score1' : 'score2';

        if (delta > 0 && checkWinCondition(m, t.pointsToWin)) return;
        
        const currentScore = m[scoreProp];
        if (currentScore + delta >= 0) {
            // Ulo≈æ√≠me historii p≈ôed zmƒõnou (pouze pro p≈ôid√°n√≠ bodu)
            if (delta > 0) {
                    state.scoreHistory.push({
                        matchId: m.id,
                        score1: m.score1,
                        score2: m.score2,
                        servingPlayer: m.servingPlayer,
                        firstServer: m.firstServer,
                        doubleRotationState: cloneState(m.doubleRotationState)
                    });
            m[scoreProp] += delta;
            
            if (isDoubleTournament(t)) {
                if (!m.doubleRotationState) {
                    initializeDoubleRotationState(t, m, m.firstServer || 1);
                } else {
                    advanceDoubleServeState(m, t);
                }
            } else {
                recalculateServiceState(m, t);
            }
            playSound(scoringSide);
        
                if (state.settings.voiceAssistEnabled) {
                    const side1Players = getSidePlayerIds(t, m, 1);
                    const side2Players = getSidePlayerIds(t, m, 2);
                    const servingSide = side1Players.includes(m.servingPlayer) ? 1 : (side2Players.includes(m.servingPlayer) ? 2 : null);
                    const servingLabel = isDoubleTournament(t)
                        ? (servingSide ? formatPlayersLabel(servingSide === 1 ? side1Players : side2Players) : '')
                        : (m.servingPlayer ? (getGlobalPlayer(m.servingPlayer)?.name || '') : '');
                    const servingPlayerScore = servingSide === 1 ? m.score1 : m.score2;
                    const otherPlayerScore = servingSide === 1 ? m.score2 : m.score1;
                    
                    if (m.completed) { // This state je nastaveno po checkWinCondition
                        const winnerSide = checkWinCondition(m, t.pointsToWin);
                        if (winnerSide) {
                            const winnerLabel = formatPlayersLabel(winnerSide === 1 ? side1Players : side2Players);
                            const winnerScore = Math.max(m.score1, m.score2);
                            const loserScore = Math.min(m.score1, m.score2);
                            speak(`Konec z√°pasu. V√≠tƒõz ${winnerLabel}. ${winnerScore} : ${loserScore}`);
                        }
                    } else if (servingLabel) {
                        let speechText = `${servingPlayerScore} : ${otherPlayerScore}, pod√°n√≠ ${servingLabel}`;
                        if (Math.random() < 0.4) {
                            const randomPhrase = encouragingPhrases[Math.floor(Math.random() * encouragingPhrases.length)];
                            speechText += `. ${randomPhrase}`;
                        }
                        speak(speechText);
                    }
                }

            const matchPayload = { ...m, tournament_id: t.id, match_order: t.matches.findIndex(match => match.id == m.id) };
            await apiCall('updateMatch', { id: m.id, data: matchPayload });
            
            renderGameBoard();
        }
    };

    const calculateOverallStats = () => {
        const overallStats = new Map();
        state.playerDatabase.forEach(p => {
            overallStats.set(p.id, { player: p, tournaments: 0, matches: 0, wins: 0, losses: 0, scoreFor: 0, scoreAgainst: 0, places: { 1: 0, 2: 0, 3: 0 } });
        });
        state.tournaments.forEach(t => {
            const completedMatches = t.matches.filter(m => m.completed);
            const playerIdsInTournament = new Set();
            completedMatches.forEach(m => {
                const side1Players = getSidePlayerIds(t, m, 1);
                const side2Players = getSidePlayerIds(t, m, 2);
                side1Players.forEach(id => playerIdsInTournament.add(id));
                side2Players.forEach(id => playerIdsInTournament.add(id));
                const winnerSide = m.score1 === m.score2 ? null : (m.score1 > m.score2 ? 1 : 2);
                side1Players.forEach(id => {
                    const stat = overallStats.get(id);
                    if (!stat) return;
                    stat.matches++;
                    stat.scoreFor += m.score1;
                    stat.scoreAgainst += m.score2;
                    if (winnerSide === 1) stat.wins++; else if (winnerSide === 2) stat.losses++;
                });
                side2Players.forEach(id => {
                    const stat = overallStats.get(id);
                    if (!stat) return;
                    stat.matches++;
                    stat.scoreFor += m.score2;
                    stat.scoreAgainst += m.score1;
                    if (winnerSide === 2) stat.wins++; else if (winnerSide === 1) stat.losses++;
                });
            });
            playerIdsInTournament.forEach(id => { const s = overallStats.get(id); if(s) s.tournaments++; });
            const isFinished = t.matches.length > 0 && completedMatches.length === t.matches.length;
            if (isFinished) {
                const ranking = calculateStats(t);
                ranking.slice(0, 3).forEach((stat, i) => {
                    const s = overallStats.get(stat.player.id);
                    if(s) s.places[i+1]++;
                });
            }
        });
        return Array.from(overallStats.values()).sort((a, b) => b.wins - a.wins || (b.scoreFor - b.scoreAgainst) - (a.scoreFor - a.scoreAgainst));
    };
    const calculateOverallTeamStats = () => {
        const teamStatsMap = new Map();
        state.tournaments.filter(isDoubleTournament).forEach(t => {
            const completedMatches = t.matches.filter(m => m.completed);
            completedMatches.forEach(m => {
                const team1Players = getSidePlayerIds(t, m, 1);
                const team2Players = getSidePlayerIds(t, m, 2);
                const key1 = getTeamKey(team1Players);
                const key2 = getTeamKey(team2Players);
                if (!teamStatsMap.has(key1)) {
                    teamStatsMap.set(key1, { players: team1Players.slice().sort((a, b) => a - b), label: formatPlayersLabel(team1Players), matches: 0, wins: 0, losses: 0, scoreFor: 0, scoreAgainst: 0, tournaments: new Set([t.id]) });
                } else {
                    teamStatsMap.get(key1).tournaments.add(t.id);
                }
                if (!teamStatsMap.has(key2)) {
                    teamStatsMap.set(key2, { players: team2Players.slice().sort((a, b) => a - b), label: formatPlayersLabel(team2Players), matches: 0, wins: 0, losses: 0, scoreFor: 0, scoreAgainst: 0, tournaments: new Set([t.id]) });
                } else {
                    teamStatsMap.get(key2).tournaments.add(t.id);
                }
                const team1 = teamStatsMap.get(key1);
                const team2 = teamStatsMap.get(key2);
                team1.matches++; team2.matches++;
                team1.scoreFor += m.score1; team1.scoreAgainst += m.score2;
                team2.scoreFor += m.score2; team2.scoreAgainst += m.score1;
                if (m.score1 > m.score2) { team1.wins++; team2.losses++; } else { team2.wins++; team1.losses++; }
            });
        });
        return Array.from(teamStatsMap.values()).map(stat => ({
            ...stat,
            tournaments: stat.tournaments.size
        })).sort((a, b) => b.wins - a.wins || (b.scoreFor - b.scoreAgainst) - (a.scoreFor - a.scoreAgainst));
    };

    const renderOverallStatsScreen = () => {
        const stats = calculateOverallStats();
        const teamStats = calculateOverallTeamStats();
        const container = document.getElementById('overall-stats-container');
        let html = `<table class="w-full text-sm text-left">
            <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                <tr>
                    <th class="px-2 py-3">Hr√°ƒç</th><th class="px-2 py-3 text-center" title="Odehran√© turnaje">T</th><th class="px-2 py-3 text-center" title="Odehran√© z√°pasy">Z</th><th class="px-2 py-3 text-center" title="V√Ωhry">V</th><th class="px-2 py-3 text-center" title="Prohry">P</th><th class="px-2 py-3 text-center" title="Celkov√© sk√≥re">Sk√≥re</th><th class="px-2 py-3 text-center">üèÜ</th><th class="px-2 py-3 text-center">ü•à</th><th class="px-2 py-3 text-center">ü•â</th>
                </tr>
            </thead>
            <tbody>${stats.map(s => `<tr class="bg-white border-b"><td class="px-2 py-4 font-semibold">${s.player.name}</td><td class="px-2 py-4 text-center">${s.tournaments}</td><td class="px-2 py-4 text-center">${s.matches}</td><td class="px-2 py-4 text-center text-green-600">${s.wins}</td><td class="px-2 py-4 text-center text-red-600">${s.losses}</td><td class="px-2 py-4 text-center">${s.scoreFor}:${s.scoreAgainst}</td><td class="px-2 py-4 text-center">${s.places[1]}</td><td class="px-2 py-4 text-center">${s.places[2]}</td><td class="px-2 py-4 text-center">${s.places[3]}</td></tr>`).join('')}</tbody>
        </table>`;
        if (teamStats.length) {
            html += `<div class="mt-6">
                <h2 class="text-lg font-semibold mb-2">T√Ωmy (v≈°echny turnaje)</h2>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm text-left">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                            <tr>
                                <th class="px-2 py-3">T√Ωm</th><th class="px-2 py-3 text-center">Turnaje</th><th class="px-2 py-3 text-center">Z</th><th class="px-2 py-3 text-center">V</th><th class="px-2 py-3 text-center">P</th><th class="px-2 py-3 text-center">Sk√≥re</th>
                            </tr>
                        </thead>
                        <tbody>${teamStats.map(s => `<tr class="bg-white border-b"><td class="px-2 py-3 font-semibold">${s.label}</td><td class="px-2 py-3 text-center">${s.tournaments}</td><td class="px-2 py-3 text-center">${s.matches}</td><td class="px-2 py-3 text-center text-green-600">${s.wins}</td><td class="px-2 py-3 text-center text-red-500">${s.losses}</td><td class="px-2 py-3 text-center">${s.scoreFor}:${s.scoreAgainst}</td></tr>`).join('')}</tbody>
                    </table>
                </div>
            </div>`;
        }
        container.innerHTML = html;
        showScreen('overallStats');
    };

    const allActions = {
        'show-player-db': renderPlayerDbScreen,
        'show-edit-player-modal':(target)=>{const playerId=target.dataset.id==='new'?null:parseInt(target.dataset.id);const p=playerId?getGlobalPlayer(playerId):{name:'',photoUrl:'',strengths:'',weaknesses:''};openModal(`<div id="edit-player-modal" class="modal-backdrop"><div class="modal-content space-y-4"><div class="flex justify-between items-center"><h2 class="text-xl font-bold">${playerId?'Upravit hr√°ƒçe':'Nov√Ω hr√°ƒç'}</h2><button data-action="close-modal" class="text-gray-400 text-2xl hover:text-gray-700">&times;</button></div><div class="text-center"><img src="${p.photoUrl||`data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2280%22%20height%3D%2280%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Crect%20width%3D%2280%22%20height%3D%2280%22%20fill%3D%22%23e5e7eb%22%20rx%3D%2240%22%2F%3E${p.name?`%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20dominant-baseline%3D%22central%22%20text-anchor%3D%22middle%22%20font-family%3D%22Inter%22%20font-size%3D%2232%22%20fill%3D%22%239ca3af%22%3E${p.name.charAt(0).toUpperCase()}%3C%2Ftext%3E`:''}%3C%2Fsvg%3E`}" class="w-20 h-20 rounded-full object-cover bg-gray-200 inline-block"></div><div><label class="text-sm font-medium">Jm√©no</label><input id="player-name" value="${p.name}" class="w-full mt-1 p-2 border rounded-md"></div><div><label class="text-sm font-medium">URL fotografie</label><input id="player-photo" value="${p.photoUrl||''}" placeholder="https://..." class="w-full mt-1 p-2 border rounded-md"></div><div><label class="text-sm font-medium">Siln√© str√°nky</label><textarea id="player-strengths" class="w-full mt-1 p-2 border rounded-md h-20">${p.strengths||''}</textarea></div><div><label class="text-sm font-medium">Slab√© str√°nky</label><textarea id="player-weaknesses" class="w-full mt-1 p-2 border rounded-md h-20">${p.weaknesses||''}</textarea></div><div class="flex gap-2"><button data-action="close-modal" class="btn btn-secondary w-full">Zru≈°it</button><button data-action="save-player" data-id="${playerId||''}" class="btn btn-primary w-full">Ulo≈æit</button></div></div></div>`);document.getElementById('edit-player-modal').addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); document.querySelector('[data-action="save-player"]').click(); } });document.getElementById('player-name').focus();},
        'save-player': async (target) => {
            const playerId = target.dataset.id ? parseInt(target.dataset.id) : null;
            const name = document.getElementById('player-name').value.trim();
            if (!name) { alert('Jm√©no je povinn√©.'); return; }
            const payload = {
                id: playerId,
                data: {
                    name,
                    photoUrl: document.getElementById('player-photo').value.trim(),
                    strengths: document.getElementById('player-strengths').value.trim(),
                    weaknesses: document.getElementById('player-weaknesses').value.trim(),
                }
            };
            await apiCall('savePlayer', payload);
            closeModal();
            renderPlayerDbScreen();
        },
        'delete-player': async (target) => {
            const playerId = parseInt(target.dataset.id);
            const isPlayerInTournament = state.tournaments.some(t => t.playerIds.includes(playerId));
            if (isPlayerInTournament) { alert('Hr√°ƒçe nelze smazat, proto≈æe je souƒç√°st√≠ jednoho nebo v√≠ce turnaj≈Ø.'); return; }
            if (confirm('Opravdu chcete smazat tohoto hr√°ƒçe z datab√°ze?')) {
                await apiCall('deletePlayer', { id: playerId });
                renderPlayerDbScreen();
            }
        },
        'show-new-tournament-modal':()=>{tempPlayerIds=[];tempTournamentType=TOURNAMENT_TYPES.SINGLE;const defaultName = `Turnaj ${new Date().toLocaleDateString('cs-CZ')}`; const renderAddedPlayers=()=>{const list=document.getElementById('new-players-list');if(list){list.innerHTML=tempPlayerIds.map((id,index)=>{const player=getGlobalPlayer(id);return`<div class="flex items-center gap-2 bg-gray-100 p-2 rounded-md"><div class="w-5 h-5 rounded-full ${playerColors[index%playerColors.length]}"></div><span class="flex-grow">${player.name}</span><button data-action="remove-temp-player" data-id="${id}" class="text-red-500 font-bold">&times;</button></div>`}).join('')||`<div class="text-sm text-gray-500 text-center p-2">Zat√≠m ≈æ√°dn√≠ hr√°ƒçi</div>`;}const countLabel=document.getElementById('player-count-text');if(countLabel){countLabel.textContent=`Hr√°ƒçi (${tempPlayerIds.length}/${getPlayerLimitForType(tempTournamentType)})`;const note=document.getElementById('player-count-note');if(note){note.textContent=tempTournamentType===TOURNAMENT_TYPES.DOUBLE&&tempPlayerIds.length%2!==0?'ƒåty≈ôhra vy≈æaduje sud√Ω poƒçet hr√°ƒç≈Ø.':'';}}};const renderTypeToggle=()=>{document.querySelectorAll('[data-tournament-type]').forEach(btn=>{const isActive=btn.dataset.tournamentType===tempTournamentType;btn.classList.toggle('bg-blue-500',isActive);btn.classList.toggle('text-white',isActive);btn.classList.toggle('border-blue-500',isActive);btn.classList.toggle('bg-gray-100',!isActive);btn.classList.toggle('text-gray-700',!isActive);});const hint=document.getElementById('tournament-type-hint');if(hint){hint.textContent=tempTournamentType===TOURNAMENT_TYPES.DOUBLE?'ƒåty≈ôhra vy≈æaduje 4‚Äì16 hr√°ƒç≈Ø a sud√Ω poƒçet (t√Ωmy po dvou).':'Dvouhra vy≈æaduje 2‚Äì8 hr√°ƒç≈Ø.';}};openModal(`<div id="new-tournament-modal" class="modal-backdrop"><div class="modal-content space-y-4"><div class="flex justify-between items-center"><h2 class="text-xl font-bold">Nov√Ω turnaj</h2><button data-action="close-modal" class="text-gray-400 text-2xl hover:text-gray-700">&times;</button></div><div><label class="text-sm font-medium">N√°zev turnaje</label><input id="new-tournament-name" type="text" value="${defaultName}" class="w-full mt-1 p-2 border rounded-md"></div><div><label class="text-sm font-medium">Typ z√°pasu</label><div class="flex gap-2 mt-1"><button type="button" data-tournament-type="single" class="flex-1 p-3 border rounded-md text-center">Dvouhra</button><button type="button" data-tournament-type="double" class="flex-1 p-3 border rounded-md text-center">ƒåty≈ôhra</button></div><p class="text-xs text-gray-500 mt-1" id="tournament-type-hint"></p></div><div><label class="text-sm font-medium">Typ setu</label><div class="flex gap-2 mt-1"> <label class="flex-1 p-3 border rounded-md cursor-pointer has-[:checked]:bg-blue-50 has-[:checked]:border-blue-500 text-center"><input type="radio" name="points-to-win" value="11" class="sr-only" checked><span>Mal√Ω set (11)</span></label> <label class="flex-1 p-3 border rounded-md cursor-pointer has-[:checked]:bg-blue-50 has-[:checked]:border-blue-500 text-center"><input type="radio" name="points-to-win" value="21" class="sr-only"><span>Velk√Ω set (21)</span></label></div></div><div><label id="player-count-text" class="text-sm font-medium">Hr√°ƒçi (0/${getPlayerLimitForType(tempTournamentType)})</label><div id="new-players-list" class="space-y-2 my-2">${tempPlayerIds.length>0?'':'<div class="text-sm text-gray-500 text-center p-2">Zat√≠m ≈æ√°dn√≠ hr√°ƒçi</div>'}</div><p id="player-count-note" class="text-xs text-red-500"></p><div class="relative"><input id="add-player-input" type="text" placeholder="Napi≈°te jm√©no pro p≈ôid√°n√≠..." class="w-full p-2 border rounded-md"><div id="autocomplete-container"></div></div></div><button data-action="create-tournament" class="btn btn-primary w-full">Vytvo≈ôit turnaj</button></div></div>`);setupAutocomplete('add-player-input','autocomplete-container',(id)=>{const maxPlayers=getPlayerLimitForType(tempTournamentType);if(tempPlayerIds.length<maxPlayers&&!tempPlayerIds.includes(id)){tempPlayerIds.push(id);renderAddedPlayers();}else if(tempPlayerIds.includes(id)){alert('Hr√°ƒç je ji≈æ v seznamu.');}else{alert(`Maxim√°ln√≠ poƒçet hr√°ƒç≈Ø pro tento form√°t je ${maxPlayers}.`);}},tempPlayerIds);document.querySelectorAll('[data-tournament-type]').forEach(btn=>{btn.addEventListener('click',()=>{const selectedType=btn.dataset.tournamentType;const maxPlayers=getPlayerLimitForType(selectedType);if(tempPlayerIds.length>maxPlayers){alert(`Pro tento form√°t je povoleno maxim√°lnƒõ ${maxPlayers} hr√°ƒç≈Ø. Nejprve hr√°ƒçe odeberte.`);return;}tempTournamentType=selectedType;renderTypeToggle();renderAddedPlayers();});});renderTypeToggle();renderAddedPlayers();document.getElementById('add-player-input').focus();document.getElementById('new-tournament-modal').addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); document.querySelector('[data-action="create-tournament"]').click(); } });},
        'remove-temp-player':(target)=>{const idToRemove=parseInt(target.dataset.id);tempPlayerIds=tempPlayerIds.filter(id=>id!==idToRemove);const list=document.getElementById('new-players-list');if(list){list.innerHTML=tempPlayerIds.map((id,index)=>{const player=getGlobalPlayer(id);return`<div class="flex items-center gap-2 bg-gray-100 p-2 rounded-md"><div class="w-5 h-5 rounded-full ${playerColors[index%playerColors.length]}"></div><span class="flex-grow">${player.name}</span><button data-action="remove-temp-player" data-id="${id}" class="text-red-500 font-bold">&times;</button></div>`}).join('')||`<div class="text-sm text-gray-500 text-center p-2">Zat√≠m ≈æ√°dn√≠ hr√°ƒçi</div>`;const countLabel=document.getElementById('player-count-text');if(countLabel){countLabel.textContent=`Hr√°ƒçi (${tempPlayerIds.length}/${getPlayerLimitForType(tempTournamentType)})`;const note=document.getElementById('player-count-note');if(note){note.textContent=tempTournamentType===TOURNAMENT_TYPES.DOUBLE&&tempPlayerIds.length%2!==0?'ƒåty≈ôhra vy≈æaduje sud√Ω poƒçet hr√°ƒç≈Ø.':'';}}}},
        'create-tournament': async () => {
            const name = document.getElementById('new-tournament-name').value.trim();
            const minPlayers = getMinPlayersForType(tempTournamentType);
            const maxPlayers = getPlayerLimitForType(tempTournamentType);
            if (!name) {
                alert('Zadejte n√°zev turnaje.');
                return;
            }
            if (tempPlayerIds.length < minPlayers) {
                alert(`Pro tento form√°t je pot≈ôeba alespo≈à ${minPlayers} hr√°ƒç≈Ø.`);
                return;
            }
            if (tempTournamentType === TOURNAMENT_TYPES.DOUBLE && tempPlayerIds.length % 2 !== 0) {
                alert('ƒåty≈ôhra vy≈æaduje sud√Ω poƒçet hr√°ƒç≈Ø.');
                return;
            }
            if (tempPlayerIds.length > maxPlayers) {
                alert(`Maxim√°ln√≠ poƒçet hr√°ƒç≈Ø je ${maxPlayers}.`);
                return;
            }
            const uniqueName = generateUniqueTournamentName(name);
            const now = new Date();
            const mysqlDate = now.getFullYear() + '-' + 
                String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                String(now.getDate()).padStart(2, '0') + ' ' + 
                String(now.getHours()).padStart(2, '0') + ':' + 
                String(now.getMinutes()).padStart(2, '0') + ':' + 
                String(now.getSeconds()).padStart(2, '0');
            const payload = {
                name: uniqueName,
                pointsToWin: parseInt(document.querySelector('input[name="points-to-win"]:checked').value),
                createdAt: mysqlDate,
                playerIds: tempPlayerIds,
                type: tempTournamentType
            };
            
            await apiCall('createTournament', payload);
            
            closeModal();
            renderMainScreen();
        },
        'show-settings-modal':()=>{const t=getTournament();const maxPlayersForTournament=getPlayerLimitForType(t.type||TOURNAMENT_TYPES.SINGLE);const matchIncludesPlayer=(match,playerId)=>{return getSidePlayerIds(t,match,1).includes(playerId)||getSidePlayerIds(t,match,2).includes(playerId);};tempPlayerIds=[...t.playerIds];const renderAddedPlayers=()=>{const list=document.getElementById('settings-players-list');if(list){list.innerHTML=tempPlayerIds.map((id,index)=>{const player=getGlobalPlayer(id);const hasActivity=t.matches.some(m=>(m.completed||m.score1>0||m.score2>0)&&matchIncludesPlayer(m,id));return`<div class="flex items-center gap-2 bg-gray-100 p-2 rounded-md"><div class="w-6 h-6 ${playerColors[index%playerColors.length]} rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">${player.name.charAt(0).toUpperCase()}</div><span class="flex-grow">${player.name}</span><button data-action="remove-player-settings" data-id="${id}" class="text-red-500 font-bold text-xl disabled:opacity-25" ${hasActivity?'disabled title="Hr√°ƒç ji≈æ m√° odehran√Ω nebo rozehran√Ω z√°pas"':''}>&times;</button></div>`}).join('')||`<div class="text-sm text-gray-500 text-center p-2">≈Ω√°dn√≠ hr√°ƒçi</div>`;document.getElementById('settings-player-count').textContent=`Hr√°ƒçi (${tempPlayerIds.length}/${maxPlayersForTournament})`;}};openModal(`<div id="settings-modal" class="modal-backdrop"><div class="modal-content space-y-4"><div class="flex justify-between items-center"><h2 class="text-xl font-bold">Nastaven√≠ turnaje</h2><button data-action="close-modal" class="text-gray-400 text-2xl hover:text-gray-700">&times;</button></div><p class="text-sm text-gray-500">Form√°t: ${getTournamentTypeLabel(t)}</p><div><label class="text-sm font-medium">N√°zev turnaje</label><input id="edit-tournament-name" value="${t.name}" class="w-full mt-1 p-2 border rounded-md" ${t.isLocked?'disabled':''}></div><div><label id="settings-player-count" class="text-sm font-medium">Hr√°ƒçi</label><div id="settings-players-list" class="space-y-2 my-2"></div><div class="relative"${t.isLocked?'hidden':''}><input id="add-player-input-settings" type="text" placeholder="P≈ôidat dal≈°√≠ho hr√°ƒçe..." class="w-full p-2 border rounded-md"><div id="autocomplete-container-settings"></div></div></div><button data-action="save-settings" class="btn btn-primary w-full">Ulo≈æit zmƒõny</button><div class="border-t pt-4 mt-4 space-y-2"><label class="text-sm font-medium text-gray-500">Servisn√≠ akce</label><div class="flex gap-2 flex-wrap"><button data-action="copy-tournament" class="btn btn-secondary w-full text-sm"><i class="fa-solid fa-copy"></i> Kop√≠rovat turnaj</button><button data-action="toggle-lock-settings" class="btn btn-secondary w-full text-sm">${t.isLocked?'üîì Odemknout':'üîí Zamknout'}</button><button data-action="delete-tournament-settings" class="btn btn-danger w-full text-sm">Smazat turnaj</button></div></div></div></div>`);renderAddedPlayers();setupAutocomplete('add-player-input-settings','autocomplete-container-settings',(id)=>{if(tempPlayerIds.length<maxPlayersForTournament&&!tempPlayerIds.includes(id)){tempPlayerIds.push(id);renderAddedPlayers();}},tempPlayerIds);document.getElementById('settings-modal').addEventListener('keydown',(e)=>{if(e.key==='Enter'&&e.ctrlKey){e.preventDefault();document.querySelector('[data-action="save-settings"]').click();}});},
        'remove-player-settings':(target)=>{const idToRemove=parseInt(target.dataset.id);tempPlayerIds=tempPlayerIds.filter(id=>id!==idToRemove);const t=getTournament();const maxPlayersForTournament=getPlayerLimitForType(t.type||TOURNAMENT_TYPES.SINGLE);const matchIncludesPlayer=(match,playerId)=>{return getSidePlayerIds(t,match,1).includes(playerId)||getSidePlayerIds(t,match,2).includes(playerId);};const renderAddedPlayers=()=>{const list=document.getElementById('settings-players-list');if(list){list.innerHTML=tempPlayerIds.map((id,index)=>{const player=getGlobalPlayer(id);const hasActivity=t.matches.some(m=>(m.completed||m.score1>0||m.score2>0)&&matchIncludesPlayer(m,id));return`<div class="flex items-center gap-2 bg-gray-100 p-2 rounded-md"><div class="w-6 h-6 ${playerColors[index%playerColors.length]} rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">${player.name.charAt(0).toUpperCase()}</div><span class="flex-grow">${player.name}</span><button data-action="remove-player-settings" data-id="${id}" class="text-red-500 font-bold text-xl disabled:opacity-25" ${hasActivity?'disabled title="Hr√°ƒç ji≈æ m√° odehran√Ω nebo rozehran√Ω z√°pas"':''}>&times;</button></div>`}).join('')||`<div class="text-sm text-gray-500 text-center p-2">≈Ω√°dn√≠ hr√°ƒçi</div>`;document.getElementById('settings-player-count').textContent=`Hr√°ƒçi (${tempPlayerIds.length}/${maxPlayersForTournament})`;}};renderAddedPlayers();},
        'save-settings': async () => {
            const t = getTournament();
            if (t.isLocked) { closeModal(); return; }

            const originalPlayerIds = [...t.playerIds];
            t.name = document.getElementById('edit-tournament-name').value.trim() || t.name;
            t.playerIds = tempPlayerIds;
            const minPlayers = getMinPlayersForType(t.type || TOURNAMENT_TYPES.SINGLE);
            const maxPlayers = getPlayerLimitForType(t.type || TOURNAMENT_TYPES.SINGLE);
            if (t.playerIds.length < minPlayers) {
                alert(`Minim√°ln√≠ poƒçet hr√°ƒç≈Ø pro tento form√°t je ${minPlayers}.`);
                return;
            }
            if (isDoubleTournament(t) && t.playerIds.length % 2 !== 0) {
                alert('ƒåty≈ôhra vy≈æaduje sud√Ω poƒçet hr√°ƒç≈Ø.');
                return;
            }
            if (t.playerIds.length > maxPlayers) {
                alert(`Maxim√°ln√≠ poƒçet hr√°ƒç≈Ø je ${maxPlayers}.`);
                return;
            }

            // Zjist√≠me, jestli se zmƒõnili hr√°ƒçi, abychom vƒõdƒõli, zda p≈ôegenerovat z√°pasy
            const playersChanged = originalPlayerIds.length !== t.playerIds.length || originalPlayerIds.some(id => !t.playerIds.includes(id));

            if (playersChanged) {
                 // Odebereme z√°pasy s hr√°ƒçi, kte≈ô√≠ ji≈æ nejsou v turnaji
                t.matches = t.matches.filter(m => {
                    const participants = [...getSidePlayerIds(t, m, 1), ...getSidePlayerIds(t, m, 2)];
                    return participants.every(id => t.playerIds.includes(id));
                });
                // Dle nov√© logiky API p≈ôegeneruje z√°pasy na backendu
            }
            
            const payload = { id: t.id, data: t };
            await apiCall('updateTournament', payload);
            
            closeModal();
            renderTournamentScreen();
        },
        'toggle-lock-settings': (target) => {
            const t = getTournament();
            if (t) {
                t.isLocked = !t.isLocked;
                allActions['show-settings-modal']();
                apiCall('toggleTournamentLock', { id: t.id });
            }
        },
        'copy-tournament': async () => {
            const t = getTournament();
            if (!t) {
                console.error('‚ùå [COPY] Turnaj nenalezen!');
                return;
            }
            
            // Ulo≈æ√≠me ID turnaje p≈ôed naƒçten√≠m stavu
            const tournamentId = t.id;
            
            // Naƒçteme aktu√°ln√≠ stav z API, abychom mƒõli v≈°echny existuj√≠c√≠ turnaje
            await loadState();
            
            // Znovu naƒçteme turnaj ze stavu (mohl se zmƒõnit po loadState)
            const currentTournament = getTournament(tournamentId);
            if (!currentTournament) {
                console.error('‚ùå [COPY] Turnaj nenalezen po naƒçten√≠ stavu!');
                return;
            }
            
            // Zjist√≠me dne≈°n√≠ datum ve form√°tu DD. MM. YYYY
            const now = new Date();
            const todayStr = `${now.getDate()}. ${now.getMonth() + 1}. ${now.getFullYear()}`;
            
            // Zkontrolujeme, jestli je v n√°zvu turnaje dne≈°n√≠ datum
            const hasTodayDate = currentTournament.name.includes(todayStr);
            
            let baseName;
            if (hasTodayDate) {
                // Pokud je v n√°zvu dne≈°n√≠ datum, pou≈æijeme st√°vaj√≠c√≠ n√°zev
                baseName = currentTournament.name;
            } else {
                // Pokud v n√°zvu nen√≠ dne≈°n√≠ datum, pou≈æijeme dne≈°n√≠ datum
                // Odstran√≠me datum z p≈Øvodn√≠ho n√°zvu (nap≈ô. "Turnaj 3. 10. 2025" -> "Turnaj")
                baseName = currentTournament.name.replace(/\d+\.\s*\d+\.\s*\d{4}/, '').trim();
                // Odstran√≠me p≈ô√≠padn√© ≈ô√≠msk√© ƒç√≠slice na konci (nap≈ô. "Turnaj II." -> "Turnaj")
                baseName = baseName.replace(/\s+[IVX]+\.?\s*$/, '').trim();
                // P≈ôid√°me dne≈°n√≠ datum
                baseName = `${baseName} ${todayStr}`;
            }
            
            // Pou≈æijeme funkci pro generov√°n√≠ unik√°tn√≠ho n√°zvu (vylouƒç√≠me p≈Øvodn√≠ turnaj)
            const newName = generateUniqueTournamentName(baseName, currentTournament.id);
            
            // Vytvo≈ô√≠me nov√Ω turnaj se stejn√Ωmi hr√°ƒçi
            // Form√°t data pro MySQL: YYYY-MM-DD HH:MM:SS
            const mysqlDate = now.getFullYear() + '-' + 
                String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                String(now.getDate()).padStart(2, '0') + ' ' + 
                String(now.getHours()).padStart(2, '0') + ':' + 
                String(now.getMinutes()).padStart(2, '0') + ':' + 
                String(now.getSeconds()).padStart(2, '0');
            
            const payload = {
                name: newName,
                pointsToWin: currentTournament.pointsToWin,
                createdAt: mysqlDate,
                playerIds: [...currentTournament.playerIds],
                type: currentTournament.type || TOURNAMENT_TYPES.SINGLE
            };
            
            let newTournament = null;
            try {
                const apiResponse = await apiCall('createTournament', payload);
                
                if (apiResponse && apiResponse.tournaments) {
                    // Hled√°me nov√Ω turnaj v odpovƒõdi z API
                    newTournament = apiResponse.tournaments.find(tour => tour.name === newName);
                    
                    // Pokud jsme ho nena≈°li podle n√°zvu, zkus√≠me naj√≠t nejnovƒõj≈°√≠ turnaj (nejvy≈°≈°√≠ ID)
                    if (!newTournament && apiResponse.tournaments.length > 0) {
                        const sortedTournaments = [...apiResponse.tournaments].sort((a, b) => parseInt(b.id) - parseInt(a.id));
                        const newestTournament = sortedTournaments[0];
                        // Pokud je nejnovƒõj≈°√≠ turnaj jin√Ω ne≈æ p≈Øvodn√≠, pou≈æijeme ho
                        if (newestTournament.id != currentTournament.id) {
                            newTournament = newestTournament;
                        }
                    }
                }
                
                // Pokud jsme ho nena≈°li v odpovƒõdi, zkus√≠me to ve stavu
                if (!newTournament) {
                    newTournament = state.tournaments.find(tour => tour.name === newName);
                    
                    // Zkus√≠me naj√≠t nejnovƒõj≈°√≠ turnaj ve stavu
                    if (!newTournament && state.tournaments.length > 0) {
                        const sortedTournaments = [...state.tournaments].sort((a, b) => parseInt(b.id) - parseInt(a.id));
                        const newestTournament = sortedTournaments[0];
                        if (newestTournament.id != currentTournament.id) {
                            newTournament = newestTournament;
                        }
                    }
                }
                
                // Pokud st√°le ne, naƒçteme data znovu
                if (!newTournament) {
                    await loadState();
                    newTournament = state.tournaments.find(tour => tour.name === newName);
                    
                    // Zkus√≠me naj√≠t nejnovƒõj≈°√≠ turnaj po naƒçten√≠
                    if (!newTournament && state.tournaments.length > 0) {
                        const sortedTournaments = [...state.tournaments].sort((a, b) => parseInt(b.id) - parseInt(a.id));
                        const newestTournament = sortedTournaments[0];
                        if (newestTournament.id != currentTournament.id) {
                            newTournament = newestTournament;
                        }
                    }
                }
            } catch (error) {
                console.error('‚ùå [COPY] Chyba p≈ôi vytv√°≈ôen√≠ turnaje:', error);
                alert('Chyba p≈ôi vytv√°≈ôen√≠ kopie turnaje: ' + error.message);
                return;
            }
            
            if (newTournament) {
                // Pro ka≈æd√Ω z√°pas nastav√≠me sides_swapped = true
                for (const match of newTournament.matches) {
                    const matchPayload = {
                        tournament_id: parseInt(newTournament.id),
                        player1Id: match.player1Id || match.player1_id,
                        player2Id: match.player2Id || match.player2_id,
                        team1Id: match.team1Id || match.team1_id || null,
                        team2Id: match.team2Id || match.team2_id || null,
                        score1: match.score1 || 0,
                        score2: match.score2 || 0,
                        completed: match.completed || 0,
                        firstServer: match.firstServer || match.first_server || null,
                        servingPlayer: match.servingPlayer || match.serving_player || null,
                        match_order: newTournament.matches.findIndex(m => m.id == match.id),
                        sidesSwapped: true,
                        doubleRotationState: match.doubleRotationState || match.double_rotation_state || null
                    };
                    try {
                        await apiCall('updateMatch', { id: match.id, data: matchPayload });
                    } catch (error) {
                        console.error('‚ùå [COPY] Chyba p≈ôi √∫pravƒõ z√°pasu:', match.id, error);
                    }
                }
            } else {
                console.error('‚ùå [COPY] Nov√Ω turnaj nebyl nalezen po vytvo≈ôen√≠!');
                alert('Turnaj byl vytvo≈ôen, ale nepoda≈ôilo se ho naj√≠t. Obnovte str√°nku.');
            }
            
            closeModal();
            renderMainScreen();
        },
        'delete-tournament-settings': () => { const t = getTournament(); if(confirm(`Opravdu chcete trvale smazat turnaj "${t.name}"?`)){ allActions['delete-tournament']({ dataset: { id: t.id } }); closeModal(); } },
        'toggle-lock-main': (target) => {
            const tournamentId = parseInt(target.dataset.id);
            const t = getTournament(tournamentId);
            if (t) {
                t.isLocked = !t.isLocked;
                renderMainScreen();
                apiCall('toggleTournamentLock', { id: tournamentId });
            }
        },
        'open-tournament':(target)=>{state.activeTournamentId=parseInt(target.dataset.id);renderTournamentScreen();},
        'delete-tournament': async (target) => {
            if (confirm('Opravdu smazat?')) {
                const tournamentId = parseInt(target.dataset.id);
                await apiCall('deleteTournament', { id: tournamentId });
                renderMainScreen();
            }
        },
        'back-to-main':renderMainScreen,
        'back-to-tournament':renderTournamentScreen,
        'show-stats':()=>renderStatsScreen(),
        'export-csv':()=>exportToCSV(),
        'export-pdf':()=>exportToPDF(),
        'show-overall-stats':()=>renderOverallStatsScreen(),
        'play-match': (target) => {
            state.activeMatchId = target.dataset.id;
            // Vyma≈æeme historii p≈ôi spu≈°tƒõn√≠ nov√©ho z√°pasu
            state.scoreHistory = [];
            const m = getMatch(getTournament(), state.activeMatchId);
            if (!m) { console.error("Match not found!", state.activeMatchId); return; }
            m.score1 = m.score1 || 0;
            m.score2 = m.score2 || 0;
            if (!m.firstServer) {
                renderStartMatchModal(m);
            } else {
                renderGameBoard();
            }
        },
        'set-first-server': async (target) => {
            const t = getTournament();
            const m = getMatch(t, state.activeMatchId);
            if (!m || !t) {
                return;
            }

            const teamSide = target.dataset.teamSide ? parseInt(target.dataset.teamSide, 10) : null;
            if (teamSide && isDoubleTournament(t)) {
                m.firstServer = teamSide;
                initializeDoubleRotationState(t, m, teamSide);
            } else {
                const selectedPlayerId = parseInt(target.dataset.playerId, 10);
                m.firstServer = (selectedPlayerId === m.player1Id) ? 1 : 2;
                m.servingPlayer = selectedPlayerId;
                m.doubleRotationState = null;
            }
            
            const matchPayload = { ...m, tournament_id: t.id, match_order: t.matches.findIndex(match => match.id == m.id) };
            await apiCall('updateMatch', { id: m.id, data: matchPayload });

            closeModal();
            renderGameBoard();
        },
        'add-point': (target) => {
            const playerId = target.dataset.playerId ? parseInt(target.dataset.playerId) : null;
            const side = target.dataset.side ? parseInt(target.dataset.side) : null;
            updateScore(playerId, 1, side);
        },
        'subtract-point': (_, evt) => { evt?.stopPropagation(); undoLastPoint(); },
        'undo-last-point': undoLastPoint,
        'suspend-match':()=>{renderTournamentScreen();}, // Pouze se vrac√≠, nen√≠ t≈ôeba ukl√°dat
        'save-match-result': async () => {
            const t = getTournament();
            const m = getMatch(t, state.activeMatchId);
            m.completed = true;
            
            const matchPayload = { ...m, tournament_id: t.id, match_order: t.matches.findIndex(match => match.id == m.id) };
            await apiCall('updateMatch', { id: m.id, data: matchPayload });

            const completedCount = t.matches.filter(m => m.completed).length;
            if (completedCount === t.matches.length) {
                openModal(`<div class="modal-backdrop"><div class="modal-content modal-lg space-y-4"><h2 class="text-2xl font-bold text-center">üèÜ Koneƒçn√© v√Ωsledky üèÜ</h2>${templates.leaderboardTable(calculateStats(t),t)}<div class="flex gap-2"><button data-action="close-and-home" class="btn btn-secondary flex-1">Zav≈ô√≠t</button><button data-action="copy-tournament" class="btn btn-primary flex-1">Kop√≠rovat turnaj</button></div></div></div>`);
            } else {
                openModal(`<div id="post-match-modal" class="modal-backdrop"><div class="modal-content modal-lg space-y-4"><h2 class="text-xl font-bold text-center">Pr≈Øbƒõ≈æn√© po≈ôad√≠</h2>${templates.leaderboardTable(calculateStats(t),t)}<button data-action="close-and-refresh" class="btn btn-primary w-full">Pokraƒçovat</button></div></div>`);
            }
        },
        'edit-match':(target)=>{const t=getTournament();const m=getMatch(t,target.dataset.id);const team1Label=formatPlayersLabel(getSidePlayerIds(t,m,1));const team2Label=formatPlayersLabel(getSidePlayerIds(t,m,2));openModal(`<div id="edit-match-modal" class="modal-backdrop"><div class="modal-content space-y-4"><h2 class="text-xl font-bold">√öprava v√Ωsledku</h2><div class="flex items-center justify-between gap-2"><span class="font-bold">${team1Label}</span><input id="edit-score1" type="number" value="${m.score1}" class="w-20 text-center text-xl p-2 border rounded"><span class="text-xl">:</span><input id="edit-score2" type="number" value="${m.score2}" class="w-20 text-center text-xl p-2 border rounded"><span class="font-bold">${team2Label}</span></div><div class="flex gap-2"><button data-action="close-modal" class="btn btn-secondary w-full">Zru≈°it</button><button data-action="save-edited-match" data-match-id="${m.id}" class="btn btn-primary w-full">Ulo≈æit</button></div></div></div>`);document.getElementById('edit-match-modal').addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); document.querySelector('[data-action="save-edited-match"]').click(); } });},
        'save-edited-match': async (target) => {
            const t = getTournament();
            const matchId = target.dataset.matchId;
            const m = getMatch(t, matchId);
            
            if (!m) {
                console.error("Z√°pas pro editaci nenalezen:", matchId);
                alert("Do≈°lo k chybƒõ, z√°pas nebyl nalezen.");
                return;
            }

            m.score1 = parseInt(document.getElementById('edit-score1').value) || 0;
            m.score2 = parseInt(document.getElementById('edit-score2').value) || 0;
            
            const matchPayload = { ...m, tournament_id: t.id, match_order: t.matches.findIndex(match => match.id == m.id) };
            await apiCall('updateMatch', { id: m.id, data: matchPayload });

            closeModal();
            renderTournamentScreen();
        },
        'close-and-refresh':()=>{closeModal();renderTournamentScreen();},
        'close-and-home':()=>{closeModal();renderMainScreen();},
        'export-data':()=>{if(state.tournaments.length===0&&state.playerDatabase.length===0){alert("Nen√≠ co exportovat.");return;}const dataStr=JSON.stringify(state,null,2);const dataBlob=new Blob([dataStr],{type:'application/json'});const url=URL.createObjectURL(dataBlob);const a=document.createElement('a');a.href=url;a.download='ping-pong-turnaje.json';a.click();URL.revokeObjectURL(url);},
        'close-modal': closeModal,
        'toggle-settings-menu': () => { 
            const menu = document.getElementById('settings-menu'); 
            menu.classList.toggle('hidden'); 
            if(!menu.classList.contains('hidden')) { 
                document.getElementById('sound-toggle').checked = state.settings.soundsEnabled; 
                document.getElementById('voice-assist-toggle').checked = state.settings.voiceAssistEnabled;
                document.getElementById('show-locked-toggle').checked = state.settings.showLockedTournaments || false;
            } 
        },
        'toggle-sound-ingame': () => { 
            state.settings.soundsEnabled = !state.settings.soundsEnabled; 
            apiCall('saveSettings', { key: 'soundsEnabled', value: state.settings.soundsEnabled });
            renderGameBoard(); 
        },
        'toggle-voice-assist-ingame': () => {
            state.settings.voiceAssistEnabled = !state.settings.voiceAssistEnabled;
            apiCall('saveSettings', { key: 'voiceAssistEnabled', value: state.settings.voiceAssistEnabled });
            if (state.settings.voiceAssistEnabled) {
                speak("Hlasov√Ω asistent zapnut.");
            } else {
                speak("Hlasov√Ω asistent vypnut.", true);
            }
            renderGameBoard();
        },
        'quick-edit-name': (target) => { const textEl = document.getElementById('tournament-name-text'); const oldName = textEl.textContent; const input = document.createElement('input'); input.type = 'text'; input.value = oldName; input.className = 'text-3xl font-bold bg-white border rounded w-full'; textEl.parentElement.replaceChild(input, textEl); input.focus(); const save = async () => { const newName = input.value.trim(); const t = getTournament(); if(newName) { t.name = newName; } await apiCall('updateTournament', { id: t.id, data: t }); renderTournamentScreen(); }; input.addEventListener('blur', save); input.addEventListener('keydown', (e) => { if(e.key === 'Enter') save(); if(e.key === 'Escape') { input.value = oldName; save(); } }); },
        'move-match': (target) => { 
            const t = getTournament(); 
            const { id, dir } = target.dataset; 
            const upcoming = t.matches.filter(m => !m.completed); 
            const index = upcoming.findIndex(m => m.id == id); // Pou≈æijeme == pro jistotu
            if (index === -1) return; 
            const otherIndex = dir === 'up' ? index - 1 : index + 1; 
            if (otherIndex < 0 || otherIndex >= upcoming.length) return; 
            
            // Prohod√≠me cel√© z√°pasy v hlavn√≠m poli `t.matches`
            const matchIdToMove = upcoming[index].id;
            const otherMatchId = upcoming[otherIndex].id;
            const originalIndex = t.matches.findIndex(m => m.id == matchIdToMove);
            const otherOriginalIndex = t.matches.findIndex(m => m.id == otherMatchId);

            [t.matches[originalIndex], t.matches[otherOriginalIndex]] = [t.matches[otherOriginalIndex], t.matches[originalIndex]]; 
            
            // Po lok√°ln√≠m prohozen√≠ po≈°leme nov√© po≈ôad√≠ na server
            const upcomingMatchIds = t.matches.filter(m => !m.completed).map(m => m.id);
            apiCall('reorderMatches', { matchIds: upcomingMatchIds });
            
            renderTournamentScreen(); 
        },
        'swap-sides': (target) => {
            const t = getTournament();
            const matchId = target.dataset.id;
            const m = getMatch(t, matchId);
            if (m && !t.isLocked) {
                m.sidesSwapped = !m.sidesSwapped;
                apiCall('swapSides', { matchId: m.id });
                renderTournamentScreen();
            }
        }
    };
    
    app.addEventListener('click', (e) => { 
        initializeAudio();
        const target = e.target.closest('[data-action]'); 
        if (!e.target.closest('#settings-menu') && !e.target.closest('[data-action="toggle-settings-menu"]')) {
            document.getElementById('settings-menu').classList.add('hidden');
        }
        if (target && allActions[target.dataset.action]) allActions[target.dataset.action](target, e); 
    });
    app.addEventListener('change', (e) => {
        const soundToggle = e.target.closest('[data-action="toggle-sound"]');
        if (soundToggle) { 
            state.settings.soundsEnabled = soundToggle.checked;
            apiCall('saveSettings', { key: 'soundsEnabled', value: state.settings.soundsEnabled });
        }
        const voiceToggle = e.target.closest('[data-action="toggle-voice-assist"]');
        if (voiceToggle) {
            state.settings.voiceAssistEnabled = voiceToggle.checked;
            apiCall('saveSettings', { key: 'voiceAssistEnabled', value: state.settings.voiceAssistEnabled });
            if (state.settings.voiceAssistEnabled) {
                // Kr√°tk√° prodleva, aby se p≈ô√≠padnƒõ stihlo zav≈ô√≠t menu
                setTimeout(() => speak("Hlasov√Ω asistent zapnut."), 100);
            }
        }
        const showLockedToggle = e.target.closest('[data-action="toggle-show-locked"]');
        if (showLockedToggle) {
            state.settings.showLockedTournaments = showLockedToggle.checked;
            apiCall('saveSettings', { key: 'showLockedTournaments', value: state.settings.showLockedTournaments });
            renderMainScreen();
        }
    });
    document.getElementById('import-file').addEventListener('change', (event) => {
        const file = event.target.files[0]; if (!file) return;
        if ((state.tournaments.length > 0 || state.playerDatabase.length > 0) && !confirm("Opravdu chcete importovat nov√° data? V≈°echna st√°vaj√≠c√≠ data budou p≈ôeps√°na.")) { event.target.value = ''; return; }
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                if (importedData && (Array.isArray(importedData.tournaments) && Array.isArray(importedData.playerDatabase))) {
                    state.tournaments = importedData.tournaments; 
                    state.playerDatabase = importedData.playerDatabase;
                    state.settings = importedData.settings || { soundsEnabled: true };
                    // Zde by se musela volat komplexn√≠ synchronizaƒçn√≠ akce na API
                    alert("Import dat v datab√°zov√© verzi nen√≠ zat√≠m podporov√°n.");
                    // saveState(); renderMainScreen(); alert("Data byla √∫spƒõ≈°nƒõ importov√°na.");
                } else { throw new Error("Invalid data format"); }
            } catch (error) { alert("Chyba: Soubor je po≈°kozen√Ω nebo m√° nespr√°vn√Ω form√°t."); }
            event.target.value = '';
        };
        reader.readAsText(file);
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modalsContainer.children.length > 0) {
            closeModal();
            return;
        }
        
        // Zkontrolujeme, jestli nen√≠ otev≈ôen√Ω input nebo textarea
        const activeElement = document.activeElement;
        const isInputActive = activeElement && (
            activeElement.tagName === 'INPUT' || 
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.isContentEditable
        );
        
        if (isInputActive) return;
        
        // Kl√°vesov√© zkratky pro p≈ôid√°v√°n√≠ bod≈Ø (pouze p≈ôi aktivn√≠ h≈ôe)
        if (screens.game.classList.contains('active') && modalsContainer.children.length === 0) {
            const t = getTournament();
            const m = getMatch(t, state.activeMatchId);
            
            if (m && !m.completed) {
                const winnerSide = checkWinCondition(m, t.pointsToWin);
                if (!winnerSide) {
                    const leftRawSide = m.sidesSwapped ? 2 : 1;
                    const rightRawSide = m.sidesSwapped ? 1 : 2;
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        updateScore(null, 1, leftRawSide);
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        updateScore(null, 1, rightRawSide);
                    }
                } else {
                    // Po v√≠tƒõzstv√≠: ≈°ipka vlevo = Zpƒõt, ≈°ipka vpravo = Ulo≈æit v√Ωsledek
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        const undoBtn = document.querySelector('[data-action="undo-last-point"]:not([disabled])');
                        if (undoBtn) undoBtn.click();
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        const saveBtn = document.querySelector('[data-action="save-match-result"]');
                        if (saveBtn) saveBtn.click();
                    }
                }
            }
            return;
        }
        
        // Kl√°vesov√© zkratky pro modaly
        if (modalsContainer.children.length > 0) {
            const modal = modalsContainer.lastElementChild;
            
            // Modal "Kdo m√° prvn√≠ pod√°n√≠" - ≈°ipka vlevo/vpravo pro hr√°ƒçe
            const firstServerBtns = modal.querySelectorAll('[data-action="set-first-server"]');
            if (firstServerBtns.length === 2) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    firstServerBtns[0].click();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    firstServerBtns[1].click();
                }
                return;
            }
            
            // Modal "Pr≈Øbƒõ≈æn√© po≈ôad√≠" - ≈°ipka vpravo pro Pokraƒçovat
            const continueBtn = modal.querySelector('[data-action="close-and-refresh"]');
            if (continueBtn && e.key === 'ArrowRight') {
                e.preventDefault();
                continueBtn.click();
                return;
            }
            
            // Modal "Koneƒçn√© v√Ωsledky" - ≈°ipka vlevo pro Zav≈ô√≠t, vpravo pro Kop√≠rovat turnaj
            const closeBtn = modal.querySelector('[data-action="close-and-home"]');
            const copyBtn = modal.querySelector('[data-action="copy-tournament"]');
            if (closeBtn && copyBtn) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    closeBtn.click();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    copyBtn.click();
                }
                return;
            }
        }
        
        // Kl√°vesov√© zkratky pro tournament screen
        if (screens.tournament.classList.contains('active')) {
            // ≈†ipka vpravo pro prvn√≠ tlaƒç√≠tko "Hr√°t z√°pas" v nadch√°zej√≠c√≠ch z√°pasech
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                const firstPlayBtn = document.querySelector('#upcoming-matches-container [data-action="play-match"]:not([disabled])');
                if (firstPlayBtn) {
                    firstPlayBtn.click();
                }
            }
            return;
        }
        
        // Kl√°vesov√© zkratky pro main screen
        if (screens.main.classList.contains('active')) {
            // ≈†ipka vpravo pro prvn√≠ tlaƒç√≠tko "Start turnaje"
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                const firstStartBtn = document.querySelector('#tournaments-list-container [data-action="open-tournament"]');
                if (firstStartBtn && firstStartBtn.textContent.includes('Start turnaje')) {
                    firstStartBtn.click();
                }
            }
        }
    });

    function renderGameBoard() {
        const t = getTournament(); 
        const m = getMatch(t, state.activeMatchId); 
        const sides = getDisplaySides(t, m);
        const rawSidePlayers = {
            1: getSidePlayerIds(t, m, 1),
            2: getSidePlayerIds(t, m, 2)
        };
        const leftRawSide = m.sidesSwapped ? 2 : 1;
        const rightRawSide = m.sidesSwapped ? 1 : 2;
        const leftScore = m.sidesSwapped ? m.score2 : m.score1;
        const rightScore = m.sidesSwapped ? m.score1 : m.score2;
        const winnerSide = checkWinCondition(m, t.pointsToWin);
        const canAddPoints = !winnerSide;
        const servingRawSide = rawSidePlayers[1].includes(m.servingPlayer) ? 1 : (rawSidePlayers[2].includes(m.servingPlayer) ? 2 : null);
        const servingLabel = m.servingPlayer
            ? (isDoubleTournament(t)
                ? formatPlayersLabel(servingRawSide === 1 ? rawSidePlayers[1] : rawSidePlayers[2])
                : (getGlobalPlayer(m.servingPlayer)?.name || '...'))
            : '...';

        const makeScoreBox = (sideDescriptor, currentScore, rawSide) => `
            <div ${canAddPoints ? `data-action="add-point" data-side="${rawSide}"` : ''} class="player-score-box ${sideDescriptor.colorClass} p-2 md:p-4 text-white relative flex flex-col items-center justify-center flex-1 w-1/2 h-full ${canAddPoints ? 'active-pointer cursor-pointer' : ''}">
                ${sideDescriptor.playerIds.includes(m.servingPlayer) ? `<div class="absolute top-2 left-2 md:top-4 md:left-4 w-8 h-8 md:w-10 md:h-10 rounded-full bg-yellow-400/90 text-xl md:text-2xl flex items-center justify-center">üèì</div>` : ''}
                <button data-action="subtract-point" class="absolute top-2 right-2 md:top-4 md:right-4 w-10 h-10 md:w-12 md:h-12 bg-black/20 rounded-full text-xl md:text-2xl">-1</button>
                <div class="text-xl md:text-2xl lg:text-3xl font-bold text-center">${sideDescriptor.label}</div>
                ${isDoubleTournament(t) ? `<div class="text-xs md:text-sm opacity-90">${sideDescriptor.playerIds.map(id => getGlobalPlayer(id)?.name || '???').join(' ‚Ä¢ ')}</div>` : ''}
                <div class="text-7xl md:text-8xl lg:text-9xl font-extrabold my-2 md:my-4">${currentScore}</div>
                <div class="text-xs md:text-sm opacity-80">${canAddPoints ? 'Klepnƒõte pro bod' : '&nbsp;'}</div>
            </div>
        `;

        renderGameScreen(`
            <div class="h-screen flex flex-col w-full">
                <header class="bg-white/90 backdrop-blur-sm p-2 md:p-3 shadow-sm text-center flex justify-between items-center w-full z-10 flex-shrink-0">
                    <button data-action="back-to-tournament" class="btn btn-secondary !p-1 md:!p-2 text-sm md:text-base w-20 md:w-24">P≈ôeru≈°it</button>
                    <div class="flex-grow px-2">
                        <p class="text-xs md:text-sm text-gray-500">Hraje se na ${t.pointsToWin} bod≈Ø</p>
                        <p class="text-sm md:text-base font-semibold">Pod√°n√≠: ${servingLabel}</p>
                    </div>
                    <div class="w-20 md:w-24 flex justify-end gap-1 md:gap-2">
                        <button data-action="toggle-voice-assist-ingame" class="btn btn-secondary !p-0 h-8 w-8 md:h-10 md:w-10 text-base md:text-lg" title="Zapnout/vypnout hlas">${state.settings.voiceAssistEnabled ? '<i class="fa-solid fa-comment-dots"></i>' : '<i class="fa-solid fa-comment-slash"></i>'}</button>
                        <button data-action="toggle-sound-ingame" class="btn btn-secondary !p-0 h-8 w-8 md:h-10 md:w-10 text-base md:text-lg" title="Zapnout/vypnout zvuky">${state.settings.soundsEnabled ? '<i class="fa-solid fa-volume-high"></i>' : '<i class="fa-solid fa-volume-xmark"></i>'}</button>
                    </div>
                </header>
                <div class="flex-1 flex flex-row w-full min-h-0">
                    ${makeScoreBox(sides.left, leftScore, leftRawSide)}
                    ${makeScoreBox(sides.right, rightScore, rightRawSide)}
                </div>
                ${winnerSide ? `<div class="absolute bottom-4 left-4 right-4 bg-white p-6 rounded-xl shadow-lg text-center space-y-3 z-20"><div class="text-3xl">üèÜ</div><h2 class="text-2xl font-bold">V√≠tƒõz: ${formatPlayersLabel(winnerSide === 1 ? getSidePlayerIds(t, m, 1) : getSidePlayerIds(t, m, 2))}!</h2><p class="text-gray-500">V√Ωsledek: ${m.score1} : ${m.score2}</p><div class="flex gap-2"><button data-action="undo-last-point" class="btn btn-secondary flex-1" ${state.scoreHistory.length === 0 ? 'disabled' : ''}>Zpƒõt</button><button data-action="save-match-result" class="btn btn-primary flex-1">Ulo≈æit v√Ωsledek</button></div></div>` : ''}
            </div>`
        );

        if (winnerSide) {
            const winnerLabel = formatPlayersLabel(winnerSide === 1 ? getSidePlayerIds(t, m, 1) : getSidePlayerIds(t, m, 2));
            const winnerScore = Math.max(m.score1, m.score2);
            const loserScore = Math.min(m.score1, m.score2);
            const randomPhrase = winningPhrases[Math.floor(Math.random() * winningPhrases.length)];
            speak(`Konec z√°pasu. V√≠tƒõz je ${winnerLabel} s v√Ωsledkem ${winnerScore} : ${loserScore}, ${randomPhrase}`);
        }
    };

    function escapeCsv(value) {
        if (value === null || value === undefined) return '';
        const stringValue = String(value);
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
            return `"${stringValue.replace(/"/g, '""')}"`;
        }
        return stringValue;
    }

    function exportToCSV() {
        const t = getTournament();
        const stats = calculateStats(t);
        const players = t.playerIds.map(getGlobalPlayer).filter(Boolean);
        
        let csv = `Turnaj: ${t.name}\n`;
        csv += `Datum vytvo≈ôen√≠: ${t.createdAt ? formatDate(t.createdAt) : 'Nezn√°m√©'}\n`;
        csv += `Body k v√Ωh≈ôe: ${t.pointsToWin}\n`;
        csv += `\n--- V√ùSLEDKOV√Å LISTINA ---\n`;
        csv += `Pozice,Jm√©no,V√≠tƒõzstv√≠,Por√°≈æky,Odehr√°no,√öspƒõ≈°nost (%)\n`;
        stats.forEach((s, i) => {
            csv += `${i + 1},${escapeCsv(s.player.name)},${s.wins},${s.losses},${s.played},${s.played > 0 ? Math.round((s.wins / s.played) * 100) : 0}\n`;
        });
        
        csv += `\n--- VZ√ÅJEMN√â Z√ÅPASY ---\n`;
        csv += `Hr√°ƒç,${players.map(p => escapeCsv(p.name)).join(',')}\n`;
        players.forEach(p1 => {
            const row = [escapeCsv(p1.name)];
            players.forEach(p2 => {
                if (p1.id === p2.id) {
                    row.push('-');
                } else {
                    const match = t.matches.find(m => {
                        const result = getMatchResultForPlayers(t, m, p1.id, p2.id);
                        return result && m.completed;
                    });
                    if (match) {
                        const result = getMatchResultForPlayers(t, match, p1.id, p2.id);
                        row.push(`${result.aScore}:${result.bScore}`);
                    } else {
                        row.push('?');
                    }
                }
            });
            csv += row.join(',') + '\n';
        });
        
        csv += `\n--- SEZNAM Z√ÅPAS≈Æ ---\n`;
        csv += `Hr√°ƒç 1,Hr√°ƒç 2,Sk√≥re 1,Sk√≥re 2,Dokonƒçeno\n`;
        t.matches.forEach(m => {
            const team1Label = formatPlayersLabel(getSidePlayerIds(t, m, 1));
            const team2Label = formatPlayersLabel(getSidePlayerIds(t, m, 2));
            csv += `${escapeCsv(team1Label)},${escapeCsv(team2Label)},${m.score1},${m.score2},${m.completed ? 'Ano' : 'Ne'}\n`;
        });
        
        const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `turnaj_${t.name.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        URL.revokeObjectURL(url);
    }

    function exportToPDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const t = getTournament();
        const stats = calculateStats(t);
        const players = t.playerIds.map(getGlobalPlayer).filter(Boolean);
        
        // Vytvo≈ô√≠me HTML element pro renderov√°n√≠
        const pdfContent = document.createElement('div');
        pdfContent.style.width = '210mm';
        pdfContent.style.padding = '20mm';
        pdfContent.style.fontFamily = 'Inter, sans-serif';
        pdfContent.style.backgroundColor = 'white';
        pdfContent.style.color = 'black';
        pdfContent.style.position = 'absolute';
        pdfContent.style.top = '-9999px';
        pdfContent.style.left = '0';
        
        let html = `
            <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">${t.name}</h1>
            <p style="font-size: 12px; color: #666; margin-bottom: 5px;">Datum vytvo≈ôen√≠: ${t.createdAt ? formatDate(t.createdAt) : 'Nezn√°m√©'}</p>
            <p style="font-size: 12px; color: #666; margin-bottom: 20px;">Body k v√Ωh≈ôe: ${t.pointsToWin}</p>
            
            <h2 style="font-size: 18px; font-weight: bold; margin-top: 20px; margin-bottom: 10px;">V√Ωsledkov√° listina</h2>
            <table style="width: 100%; border-collapse: collapse; margin-bottom: 30px;">
                <thead>
                    <tr style="background-color: #f3f4f6; border-bottom: 2px solid #ddd;">
                        <th style="padding: 8px; text-align: left; font-weight: bold;">Poz.</th>
                        <th style="padding: 8px; text-align: left; font-weight: bold;">Jm√©no</th>
                        <th style="padding: 8px; text-align: center; font-weight: bold;">V√≠tƒõzstv√≠</th>
                        <th style="padding: 8px; text-align: center; font-weight: bold;">Por√°≈æky</th>
                        <th style="padding: 8px; text-align: center; font-weight: bold;">Odehr√°no</th>
                        <th style="padding: 8px; text-align: center; font-weight: bold;">√öspƒõ≈°nost</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        stats.forEach((s, i) => {
            html += `
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px;">${i + 1}</td>
                    <td style="padding: 8px; font-weight: ${i === 0 && s.wins > 0 ? 'bold' : 'normal'}">${s.player.name}</td>
                    <td style="padding: 8px; text-align: center; color: #16a34a; font-weight: bold;">${s.wins}</td>
                    <td style="padding: 8px; text-align: center; color: #dc2626;">${s.losses}</td>
                    <td style="padding: 8px; text-align: center;">${s.played}</td>
                    <td style="padding: 8px; text-align: center; font-weight: 600;">${s.played > 0 ? Math.round((s.wins / s.played) * 100) : 0}%</td>
                </tr>
            `;
        });
        
        html += `
                </tbody>
            </table>
            
            <h2 style="font-size: 18px; font-weight: bold; margin-top: 20px; margin-bottom: 10px;">Vz√°jemn√© z√°pasy</h2>
            <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="padding: 6px; text-align: left; font-weight: bold; border: 1px solid #ddd;"></th>
        `;
        
        players.forEach(p => {
            html += `<th style="padding: 6px; text-align: center; font-weight: bold; border: 1px solid #ddd;">${p.name}</th>`;
        });
        
        html += `
                    </tr>
                </thead>
                <tbody>
        `;
        
        players.forEach(p1 => {
            html += `<tr><td style="padding: 6px; font-weight: bold; border: 1px solid #ddd; background-color: #f9fafb;">${p1.name}</td>`;
            players.forEach(p2 => {
                if (p1.id === p2.id) {
                    html += `<td style="padding: 6px; text-align: center; border: 1px solid #ddd; background-color: #e5e7eb;">-</td>`;
                } else {
                    const match = t.matches.find(m => {
                        const result = getMatchResultForPlayers(t, m, p1.id, p2.id);
                        return result && m.completed;
                    });
                    if (match) {
                        const result = getMatchResultForPlayers(t, match, p1.id, p2.id);
                        const bgColor = result.aScore > result.bScore ? '#dcfce7' : '#fee2e2';
                        const textColor = result.aScore > result.bScore ? '#166534' : '#991b1b';
                        html += `<td style="padding: 6px; text-align: center; border: 1px solid #ddd; background-color: ${bgColor}; color: ${textColor}; font-weight: bold;">${result.aScore}:${result.bScore}</td>`;
                    } else {
                        html += `<td style="padding: 6px; text-align: center; border: 1px solid #ddd; color: #9ca3af;">?</td>`;
                    }
                }
            });
            html += `</tr>`;
        });
        
        html += `
                </tbody>
            </table>
        `;
        
        pdfContent.innerHTML = html;
        document.body.appendChild(pdfContent);
        
        // Pou≈æijeme html2canvas p≈ô√≠mo a pak p≈ôid√°me obr√°zek do PDF
        setTimeout(() => {
            html2canvas(pdfContent, {
                scale: 2,
                useCORS: true,
                letterRendering: true,
                backgroundColor: '#ffffff',
                width: pdfContent.scrollWidth,
                height: pdfContent.scrollHeight
            }).then(canvas => {
                const imgData = canvas.toDataURL('image/png');
                const imgWidth = 210; // A4 width in mm
                const pageHeight = 297; // A4 height in mm
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                let heightLeft = imgHeight;
                
                let position = 0;
                
                doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;
                
                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight;
                    doc.addPage();
                    doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }
                
                doc.save(`turnaj_${t.name.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.pdf`);
                document.body.removeChild(pdfContent);
            }).catch(error => {
                console.error('‚ùå [PDF] Chyba p≈ôi generov√°n√≠ PDF:', error);
                document.body.removeChild(pdfContent);
                alert('Chyba p≈ôi generov√°n√≠ PDF: ' + error.message);
            });
        }, 500);
    }

    function renderStatsScreen() {
        const t = getTournament(); document.getElementById('stats-tournament-name').textContent = t.name;
        const stats = calculateStats(t); document.getElementById('stats-leaderboard').innerHTML = templates.leaderboardTable(stats, t);
        const teamContainer = document.getElementById('stats-team-leaderboard');
        if (isDoubleTournament(t)) {
            const teamStats = calculateTeamStats(t);
            teamContainer.innerHTML = templates.teamLeaderboard(teamStats);
            teamContainer.classList.toggle('hidden', teamStats.length === 0);
        } else {
            teamContainer.innerHTML = '';
            teamContainer.classList.add('hidden');
        }
        const matrixContainer = document.getElementById('stats-matrix'); const players = t.playerIds.map(getGlobalPlayer).filter(Boolean);
        let matrixHTML = `<table class="w-full text-sm text-center border-collapse"><thead><tr class="bg-gray-50"><th class="border p-2"></th>${players.map(p => `<th class="border p-2"><div class="flex items-center justify-center gap-1"><div class="w-3 h-3 rounded-full ${playerColors[t.playerIds.indexOf(p.id) % playerColors.length]}"></div> ${p.name}</div></th>`).join('')}</tr></thead><tbody>`;
        players.forEach(p1 => {
            matrixHTML += `<tr><td class="border p-2 font-bold bg-gray-50"><div class="flex items-center gap-1"><div class="w-3 h-3 rounded-full ${playerColors[t.playerIds.indexOf(p1.id) % playerColors.length]}"></div> ${p1.name}</div></td>`;
            players.forEach(p2 => {
                if (p1.id === p2.id) { matrixHTML += `<td class="border p-2 bg-gray-200"></td>`; } else {
                    const match = t.matches.find(m => {
                        const result = getMatchResultForPlayers(t, m, p1.id, p2.id);
                        return result && m.completed;
                    });
                    if (match) {
                        const result = getMatchResultForPlayers(t, match, p1.id, p2.id);
                        matrixHTML += `<td class="border p-2 font-bold ${result.aScore > result.bScore ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">${result.aScore}:${result.bScore}</td>`;
                    } else {
                        matrixHTML += `<td class="border p-2 text-gray-400">?</td>`;
                    }
                }
            }); matrixHTML += `</tr>`;
        }); matrixHTML += `</tbody></table>`;
        matrixContainer.innerHTML = matrixHTML; showScreen('stats');
    }

    (async () => {
        await loadState();
        renderMainScreen();
    })();

    const renderStartMatchModal = (m) => {
        const t = getTournament();
        if (isDoubleTournament(t)) {
            const sides = getDisplaySides(t, m);
            openModal(
                `<div class="modal-backdrop">
                    <div class="modal-content bg-white p-6 rounded-xl shadow-sm space-y-6 text-center max-w-md mx-auto my-8">
                        <h1 class="text-2xl font-bold">Start z√°pasu</h1>
                        <p class="text-gray-500">Vyberte t√Ωm, kter√Ω m√° prvn√≠ pod√°n√≠</p>
                        <div class="grid grid-cols-2 gap-4">
                            <button data-action="set-first-server" data-team-side="1" class="p-4 rounded-lg font-bold text-white ${sides.raw.side1.colorClass} hover:opacity-90">
                                ${formatPlayersLabel(sides.raw.side1.playerIds)}
                                <span class="block text-xs font-normal opacity-80">${sides.raw.side1.playerIds.map(id => getGlobalPlayer(id)?.name || '???').join(' ‚Ä¢ ')}</span>
                            </button>
                            <button data-action="set-first-server" data-team-side="2" class="p-4 rounded-lg font-bold text-white ${sides.raw.side2.colorClass} hover:opacity-90">
                                ${formatPlayersLabel(sides.raw.side2.playerIds)}
                                <span class="block text-xs font-normal opacity-80">${sides.raw.side2.playerIds.map(id => getGlobalPlayer(id)?.name || '???').join(' ‚Ä¢ ')}</span>
                            </button>
                        </div>
                        <button data-action="close-modal" class="btn btn-secondary w-full mt-4">Zpƒõt</button>
                    </div>
                </div>`
            );
            return;
        }

        const p1 = getGlobalPlayer(m.player1Id);
        const p2 = getGlobalPlayer(m.player2Id);
        const displayP1 = m.sidesSwapped ? p2 : p1;
        const displayP2 = m.sidesSwapped ? p1 : p2;
        const p1Color = playerColors[t.playerIds.indexOf(displayP1.id) % playerColors.length];
        const p2Color = playerColors[t.playerIds.indexOf(displayP2.id) % playerColors.length];

        openModal(
            `<div class="modal-backdrop">
                <div class="modal-content bg-white p-6 rounded-xl shadow-sm space-y-6 text-center max-w-md mx-auto my-8">
                    <h1 class="text-2xl font-bold">${displayP1.name} vs ${displayP2.name}</h1>
                    <p class="text-gray-500">Hraje se na ${t.pointsToWin} bod≈Ø</p>
                    <div>
                        <h2 class="text-lg font-semibold mb-3">Kdo m√° prvn√≠ pod√°n√≠?</h2>
                        <div class="grid grid-cols-2 gap-4">
                            <button data-action="set-first-server" data-player-id="${displayP1.id}" class="p-4 rounded-lg font-bold text-white ${p1Color} hover:opacity-90">${displayP1.name}</button>
                            <button data-action="set-first-server" data-player-id="${displayP2.id}" class="p-4 rounded-lg font-bold text-white ${p2Color} hover:opacity-90">${displayP2.name}</button>
                        </div>
                    </div>
                    <button data-action="close-modal" class="btn btn-secondary w-full mt-4">Zpƒõt</button>
                </div>
            </div>`
        );
    }
});
</script>
</body>
</html>